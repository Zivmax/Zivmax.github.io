<!DOCTYPE html>
<html lang="zh-CN,en,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/soundwave.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/soundwave.svg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/soundwave.svg">
  <link rel="mask-icon" href="/images/soundwave.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zivmax.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="RISC-V edition.">
<meta property="og:type" content="article">
<meta property="og:title" content="CS110 Note [3]">
<meta property="og:url" content="https://zivmax.top/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2024/02/24/CS110/CS110-Note-3/index.html">
<meta property="og:site_name" content="青山后小塘">
<meta property="og:description" content="RISC-V edition.">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-02-24T08:32:40.000Z">
<meta property="article:modified_time" content="2024-03-30T06:34:33.577Z">
<meta property="article:author" content="Zivmax">
<meta property="article:tag" content="CS110">
<meta property="article:tag" content="上科大">
<meta property="article:tag" content="计算机体系架构">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="Unfinished">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zivmax.top/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2024/02/24/CS110/CS110-Note-3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>CS110 Note [3] | 青山后小塘</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  <!-- require APlayer -->
  <link rel="stylesheet" href="/dist/APlayer.min.css"media="all">
  <div id="aplayer"></div>
  <script src="/dist/APlayer.min.js"></script>
  <!-- require MetingJS -->
  <script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
<link rel="alternate" href="/atom.xml" title="青山后小塘" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">

  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">青山后小塘</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">人生如逆旅，我亦是行人</p>
      <a>
        <img class="custom-logo-image" src="/uploads/cib-boeing.svg" alt="青山后小塘">
      </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">37</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">73</span></a>

  </li>
        <li class="menu-item menu-item-playlist">

    <a href="/playlist/" rel="section"><i class="fa fa-music fa-fw"></i>歌单</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zivmax.top/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2024/02/24/CS110/CS110-Note-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zivmax">
      <meta itemprop="description" content="记录我在 STU 的所见所闻,以及成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青山后小塘">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CS110 Note [3]
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间: 2024-02-24 16:32:40" itemprop="dateCreated datePublished" datetime="2024-02-24T16:32:40+08:00">2024-02-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间: 2024-03-30 14:34:33" itemprop="dateModified" datetime="2024-03-30T14:34:33+08:00">2024-03-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数: </span>
              <span>31k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3:14</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>RISC-V edition.</p>
<span id="more"></span>
<h1 id="Operations-of-the-Computer-Hardware">Operations of the Computer Hardware</h1>
<h2 id="Instruction-set">Instruction set</h2>
<p>In the introduction, we have learned that the CPU have the basic instructions to perform, like <code>add</code>, <code>subtract</code>, <code>load</code>, <code>store</code>, <code>branch</code>, <code>jump</code>, etc. These instructions are the basic operations of the computer hardware.</p>
<p>By combining these basic operations, we can perform more complex operations, like <code>multiplication</code>, <code>division</code>, <code>array access</code>, <code>function call</code>, etc.</p>
<p>However, how to define the most basic operations of the computer hardware? Actually there's no standard answer to this question. We have many different designs which all ahiceve the same goal: using the basic operations to perform complex operations.</p>
<p>Different CPU using different instruction set have different basic operations could be performed. In my notes, I will always use the RISC-V instruction set as the example.</p>
<h2 id="Assembly-Language">Assembly Language</h2>
<p>In the introduction, we also learned that the programming language to directly describe these operations is called <em>assembly language</em>.</p>
<blockquote>
<p>Here's a example of the RISC-V assembly language:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;add x1, x2, x3</span><br></pre></td></tr></table></figure>
<p>This instruction means that the value of <code>x2</code> and <code>x3</code> will be added together, and the result will be stored in <code>x1</code>.</p>
</blockquote>
<p>Each instruction set have its own assembly language. Below is the little more detailed introduction of the RISC-V instruction set.</p>
<p>The table shows the <strong>basic operations</strong> of the RISC-V assembly language:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Operation</th>
<th style="text-align:center">Name</th>
<th>Example</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>add</code></td>
<td style="text-align:center">Add</td>
<td><code>add x1, x2, x3</code></td>
<td><code>x1 = x2 + x3</code></td>
</tr>
<tr>
<td style="text-align:center"><code>sub</code></td>
<td style="text-align:center">Subtract</td>
<td><code>sub x1, x2, x3</code></td>
<td><code>x1 = x2 - x3</code></td>
</tr>
<tr>
<td style="text-align:center"><code>addi</code></td>
<td style="text-align:center">Add immediate</td>
<td><code>addi x1, x2, 100</code></td>
<td><code>x1 = x2 + 100</code></td>
</tr>
<tr>
<td style="text-align:center"><code>ld</code></td>
<td style="text-align:center">Load doubleword</td>
<td><code>lw x1, 100(x2)</code></td>
<td><code>x1 = Memory[x2+100]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>sd</code></td>
<td style="text-align:center">Store doubleword</td>
<td><code>sw x1, 100(x2)</code></td>
<td><code>Memory[x2+100] = x1</code></td>
</tr>
<tr>
<td style="text-align:center"><code>beq</code></td>
<td style="text-align:center">Branch if equal</td>
<td><code>beq x1, x2, 100</code></td>
<td><code>if (x1 == x2) go to PC += 100</code></td>
</tr>
<tr>
<td style="text-align:center"><code>jal</code></td>
<td style="text-align:center">Jump and link</td>
<td><code>jal x1, 100</code></td>
<td><code>x1 = PC+4; go to PC += 100</code></td>
</tr>
</tbody>
</table>
<p>Clearly the tables are not complete, for the full list of the RISC-V assembly language, go check the <a target="_blank" rel="noopener" href="https://msyksphinz-self.github.io/riscv-isadoc/html/">RISC-V is a Doc</a>.</p>
<blockquote>
<p><em><strong>Tips:</strong></em> <em>(useful for reading Doc)</em></p>
<p>The base of RISC-V ISA is defined by the integer instruction set, which can be either 32-bit, 64-bit. This is indicated by the number following &quot;RISC-V&quot;. For example:</p>
<ul>
<li><strong>RISC-V32:</strong> This specifies the 32-bit integer instruction set.</li>
<li><strong>RISC-V64:</strong> This specifies the 64-bit integer instruction set.</li>
</ul>
<p>RISC-V is designed to be modular, allowing for various standard extensions that provide additional functionality beyond the base integer instruction set. These extensions are indicated by letters following the base designation. Some of the standard extensions include:</p>
<ul>
<li>
<p><strong>I:</strong> Integer. This is the base integer instruction set and is always present. It includes instructions for arithmetic, logical operations, and control flow.</p>
</li>
<li>
<p><strong>M:</strong> Multiply and Divide. This extension adds instructions for multiplication and division.</p>
</li>
<li>
<p><strong>A:</strong> Atomic. This extension adds instructions for atomic memory operations, which are crucial for multi-threading and concurrency.</p>
</li>
<li>
<p><strong>F:</strong> Single-Precision Floating-Point. This extension adds instructions for single-precision (32-bit) floating-point arithmetic.</p>
</li>
<li>
<p><strong>D:</strong> Double-Precision Floating-Point. This extension adds instructions for double-precision (64-bit) floating-point arithmetic.</p>
</li>
<li>
<p><strong>C:</strong> Compressed. This extension adds compressed instructions that are shorter than the standard instructions, allowing for more compact code. These instructions are also called psuedo-instructions.</p>
</li>
</ul>
</blockquote>
<h1 id="Operands-of-the-Computer-Hardware">Operands of the Computer Hardware</h1>
<p>The table shows the <strong>operands</strong> of the RISC-V instruction set:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Operand</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>x1</code> to <code>x31</code></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span></span></span></span> Registers</td>
</tr>
<tr>
<td style="text-align:center"><code>(0)</code> to <code>(2^61)</code></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>61</mn></msup></mrow><annotation encoding="application/x-tex">2^{61}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">61</span></span></span></span></span></span></span></span></span></span></span></span> Memory words</td>
</tr>
</tbody>
</table>
<h2 id="Register-Operands">Register Operands</h2>
<p>Registers are the smallest and fastest memory, and they are used to store the intermediate results of the computation or the most frequent accessed data.</p>
<p>Programs often have more variables than a computer's registers can hold. To manage this, compilers prioritize keeping frequently used variables in registers, relegating others to memory. This involves transferring variables between registers and memory as needed. The act of moving less frequently used variables to memory is known as <em>spilling registers</em>.</p>
<p>Because registers are embeded in the CPU, so the CPU can access the registers directly. Thus the access time is very short (faster than 0.25ns). Each register can store 64 bits of data. Since 64 bits is so often used, this size is called a <em>doubleword</em>. (while 32 bits is called a <em>word</em>.)</p>
<p>As the CPU can directly access the registers, we can surely use the registers in out assmebly code. The RISC-V instruction set have 32 registers, and they are named from <code>x1</code> to <code>x31</code>. So when we use those variables in the assembly code, we are using the register.</p>
<p>The follwing C code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = (g + h) - (i + j);</span><br></pre></td></tr></table></figure>
<p>should be compiled to the following RISC-V assembly code:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add x1, x2, x3</span><br><span class="line">add x4, x5, x6</span><br><span class="line">sub x7, x1, x4</span><br></pre></td></tr></table></figure>
<p>If <code>f</code>, <code>g</code>, <code>h</code>, <code>i</code>, <code>j</code> are assigned to <code>x7</code>, <code>x2</code>, <code>x3</code>, <code>x5</code>, <code>x6</code> respectively. And <code>x1</code>, <code>x4</code> are used as the temporary registers.</p>
<p>An important thing to notice is that, <strong>only on registers can arithmetic operations be performed</strong>.</p>
<h2 id="Memory-Operands">Memory Operands</h2>
<p>Limited amount of registers can not be used to construct the essential data structure, which sotres most of the data that programmer handles. But computer's main memory contains billions of <em>bytes</em>. Hence data structures are kept in the main memory.</p>
<p>Since 8 bits is so often used, this size is called a <em>byte</em>. And the memory is organized as a sequence of bytes. Each byte has a unique address, and the address is used to locate the data in the memory.</p>
<p>As we mentioned before, only registers can be used to perform arithmetic operations. So when we want to perform arithmetic operations on the data in the memory, we have to load the data from the memory to the registers, perform the operations, and then store the result back to the memory. Such instructions are called <em>data transfer instructions.</em></p>
<p>To access the memory, we have to use the memory address. The memory address is a 64-bit number, and it is used to locate the data in the memory. The memory address is also called <em>pointer</em>. We can abstractly think of the memory as an one dimensional array, and the memory address is the index of the array. (Under the hood, the memory is actually a 2D matrix, the address contains the row and column info.)</p>
<p>The following C code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A[<span class="number">12</span>] = h + A[<span class="number">8</span>];</span><br></pre></td></tr></table></figure>
<p>should be compiled to the following RISC-V assembly code:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ld x1, 64(x2)  // Temporarily store A[8] in reg x1</span><br><span class="line">add x1, x1, x3  // Temporarily store h + A[8] in reg x1</span><br><span class="line">sd x1, 96(x2)  // Store the result in A[12]</span><br></pre></td></tr></table></figure>
<p>If variable <code>h</code> is assigned to <code>x3</code>, and the <em>base address</em> of the array <code>A</code> is assigned to <code>x2</code>.</p>
<p>The register <code>x2</code> is used to store the base address of an array, so it is called the <em>base register</em>. And the number <code>64</code> is called the <em>offset</em>. The offset is used to locate the specific element in the array.</p>
<p>The offset in the assembly code of <code>A[8]</code> is <code>64</code> because the size of a doubleword is 8 bytes and one unique address corresponds to one byte, so the offset is <code>8 * 8 = 64</code>. The offset of <code>A[12]</code> is <code>12 * 8 = 96</code>.</p>
<h2 id="Constant-or-Imemdiate-Operands">Constant or Imemdiate Operands</h2>
<p>Many times we need to perform arithmetic operations with a constant. To utilize the constant in the assembly code, a primitive way is to load the constant to a register, and then perform the operations.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ld x1, Addr4(x3) // Load the constant 4 to x1</span><br><span class="line">add x2, x1, x4 // x2 = x1 + x4 (where x1 == 4)</span><br></pre></td></tr></table></figure>
<p>However, the RISC-V instruction set provides a more convenient way to perform the operations with a constant. The <code>addi</code> instruction can be used to add a constant to a register directly.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addi x2, x3, 4 // x2 = x3 + 4</span><br></pre></td></tr></table></figure>
<p>The constant <code>0</code> plays a special role in RISC-V. We can negate the value of a register by using the <code>x0</code> register and the <code>sub</code> instruction.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub x2, x0, x3 // x2 = 0 - x3 = -x3</span><br></pre></td></tr></table></figure>
<p>We could use the <code>x0</code> register as the constant <code>0</code> because the <code>x0</code> is hardwired to the value <code>0</code> in the RISC-V instruction set.</p>
<h1 id="Representing-Instructions-in-the-Computer">Representing Instructions in the Computer</h1>
<h2 id="Machine-Language">Machine Language</h2>
<p>Although assembly language is already the lowest level of the programming language, but computer still can not understand the assembly language directly. The computer can only understand the binary code. So the assembly language has to be translated to the binary code before the computer can execute it.</p>
<p>These numeric version of instruction is called the <em>machine language</em>. And the sequence of the machine language is called the <em>machine code</em>.</p>
<p>Infact the assembly language is close to a human readable form of the binary code, so it is easy to translate the assembly language to the binary code. The following is the translation of the <code>add x1, x2, x3</code> instruction to the binary code:</p>
<ul>
<li>
<p>Assembly language:</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add x1, x2, x3</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Binary code:</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000000 00011 00010 000 00001 0110011</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Writing the binary code in the decimal form:</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 3 2 0 1 51</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Each of the segments of the binary code has a specific meaning. We call those segments of the binary code the <em>fields</em> of the instruction. The fields of the instruction are used to specify the operation to be performed, the operands of the operation, and the result of the operation.</p>
<p>Here a table shows the fields layout of <code>add</code> instruction:</p>
<table>
<thead>
<tr>
<th style="text-align:center">funct7</th>
<th style="text-align:center">rs2</th>
<th style="text-align:center">rs1</th>
<th style="text-align:center">funct3</th>
<th style="text-align:center">rd</th>
<th style="text-align:center">opcode</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">7bit</td>
<td style="text-align:center">5bit</td>
<td style="text-align:center">5bit</td>
<td style="text-align:center">3bit</td>
<td style="text-align:center">5bit</td>
<td style="text-align:center">7bit</td>
</tr>
</tbody>
</table>
<p>The <code>opcode</code> field is used to specify the operation to be performed. The <code>rd</code>, <code>rs1</code>, <code>rs2</code> fields are used to specify the operands of the operation. The <code>funct3</code> and <code>funct7</code> fields are used to specify the result of the operation.</p>
<p>And the layout of the fields of the instruction is called the <em>instruction format</em>. The RISC-V instruction set have three instruction formats: <em>R-type</em>, <em>I-type</em>, and <em>S-type</em>. The <code>add</code> instruction is a R-type instruction.</p>
<h2 id="Instruction-Formats">Instruction Formats</h2>
<p><code>addi</code> instruction is a I-type instruction example, and <code>ld</code> instruction is a S-type instruction example. The following table shows the fields layout of I-type and S-typeinstruction:</p>
<ul>
<li>
<p>I-type instruction format:</p>
<table>
<thead>
<tr>
<th style="text-align:center">imm[11:0]</th>
<th style="text-align:center">rs1</th>
<th style="text-align:center">funct3</th>
<th style="text-align:center">rd</th>
<th style="text-align:center">opcode</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">12bit</td>
<td style="text-align:center">5bit</td>
<td style="text-align:center">3bit</td>
<td style="text-align:center">5bit</td>
<td style="text-align:center">7bit</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>S-type instruction format:</p>
<table>
<thead>
<tr>
<th style="text-align:center">imm[11:5]</th>
<th style="text-align:center">rs2</th>
<th style="text-align:center">rs1</th>
<th style="text-align:center">funct3</th>
<th style="text-align:center">imm[4:0]</th>
<th style="text-align:center">opcode</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">7bit</td>
<td style="text-align:center">5bit</td>
<td style="text-align:center">5bit</td>
<td style="text-align:center">3bit</td>
<td style="text-align:center">5bit</td>
<td style="text-align:center">7bit</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>And then we repeat the layout of R-type for a clear view:</p>
<ul>
<li>R-type instruction format:
<table>
<thead>
<tr>
<th style="text-align:center">funct7</th>
<th style="text-align:center">rs2</th>
<th style="text-align:center">rs1</th>
<th style="text-align:center">funct3</th>
<th style="text-align:center">rd</th>
<th style="text-align:center">opcode</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">7bit</td>
<td style="text-align:center">5bit</td>
<td style="text-align:center">5bit</td>
<td style="text-align:center">3bit</td>
<td style="text-align:center">5bit</td>
<td style="text-align:center">7bit</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>There are different instruction formats because different instructions have different number of operands. And the operands of the different instructions have different size. We have to choose whether to use longer and more uniform length or shorter and more varied length of instructions. The RISC-V instruction set choose the latter.</p>
<p>Two thing to notice:</p>
<ol>
<li>
<p><strong>The <code>opcode</code> field is the first field</strong> of the instruction format, we read the fields from right to left. And in the field, we read the bits from left to right.</p>
</li>
<li>
<p>In the S-type instruction, the immediate value is divided, with the higher order bits (imm[11:5]) placed at the left of the instruction and the lower order bits (imm[4:0]) positioned at the right. i.e. <strong>we read the immediate parts from left to right.</strong></p>
</li>
</ol>
<h2 id="The-Big-Picture">The Big Picture</h2>
<p>Today’s computers are built on two key principles:</p>
<ol>
<li>Instructions are represented as numbers.</li>
<li>Programs are stored in memory to be read or written, just like data.</li>
</ol>
<p>These principles lead to the stored-program concept; its invention let the computing genie out of its bottle. Figure 2.7 shows the power of the concept; specifically, memory can contain the source code for an editor program, the corresponding compiled machine code, the text that the compiled program is using, and even the compiler that generated the machine code.</p>
<p>One consequence of instructions as numbers is that programs are often shipped as files of binary numbers. The commercial implication is that computers can inherit ready-made software provided they are compatible with an existing instruction set. Such “binary compatibility” often leads industry to align around a small number of instruction set architectures.</p>
<h1 id="Logical-Operations">Logical Operations</h1>
<h2 id="Bitwise-Operations">Bitwise Operations</h2>
<p>During the development of the computer, it soon became clear that it was useful to perform operations on the individual bits of the data instead of a bundle of bits at once. The operations that perform on the individual bits of the data are called the <em>bitwise operations</em>.</p>
<p>Here's a table shows the bitwise operations of the RISC-V instruction set:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Operation</th>
<th style="text-align:center">Instruction</th>
<th>Example</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Shift left logical</td>
<td style="text-align:center"><code>sll</code>, <code>srli</code></td>
<td><code>slli x1, x2, 3</code></td>
<td><code>x1 = x2 &lt;&lt; 3</code></td>
</tr>
<tr>
<td style="text-align:center">Shift right logical</td>
<td style="text-align:center"><code>srl</code>, <code>srli</code></td>
<td><code>srli x1, x2, 3</code></td>
<td><code>x1 = x2 &gt;&gt; 3</code></td>
</tr>
<tr>
<td style="text-align:center">Shift right arithmetic</td>
<td style="text-align:center"><code>sra</code>, <code>srai</code></td>
<td><code>srai x1, x2, 3</code></td>
<td><code>x1 = x2 &gt;&gt; 3</code></td>
</tr>
<tr>
<td style="text-align:center">Bitwise AND</td>
<td style="text-align:center"><code>and</code>, <code>andi</code></td>
<td><code>and x1, x2, x3</code></td>
<td><code>x1 = x2 &amp; x3</code></td>
</tr>
<tr>
<td style="text-align:center">Bitwise OR</td>
<td style="text-align:center"><code>or</code>, <code>ori</code></td>
<td><code>or x1, x2, x3</code></td>
<td><code>x1 = x2 | x3</code></td>
</tr>
<tr>
<td style="text-align:center">Bitwise XOR</td>
<td style="text-align:center"><code>xor</code>, <code>xori</code></td>
<td><code>xor x1, x2, x3</code></td>
<td><code>x1 = x2 ^ x3</code></td>
</tr>
<tr>
<td style="text-align:center">Bitwise NOT</td>
<td style="text-align:center"><code>xori</code></td>
<td><code>not x1, x2</code></td>
<td><code>x1 = ~x2</code></td>
</tr>
</tbody>
</table>
<h2 id="Shift-Operations">Shift Operations</h2>
<p>The shift operations are used to move the bits of the data to the left or to the right. The <code>sll</code> instruction is used to shift the bits of the data to the left, and the <code>srl</code> instruction is used to shift the bits of the data to the right. The <code>sra</code> instruction is used to shift the bits of the data to the right, and the most sign bit of the old data will be filled with the original value of the sign bit.</p>
<p>If we use constant to determine the number of bits to be shifted, we can use the <code>slli</code>, <code>srli</code>, and <code>srai</code> instructions, where the <code>i</code> in the instruction name stands for <em>immediate</em>.</p>
<p>Here's some examples of the shift operations:</p>
<ul>
<li>
<p>Shift left 3 bits:</p>
<p><code>00000101</code> to <code>00101000</code></p>
</li>
<li>
<p>Shift right 3 bits:</p>
<p><code>10100000</code> to <code>00010100</code></p>
</li>
<li>
<p>Shift right arithmetic 3 bits:</p>
<p><code>10100000</code> to <code>11110100</code></p>
<p><code>01100000</code> to <code>00001100</code></p>
</li>
</ul>
<h2 id="AND-OR-NOT-XOR">AND, OR, NOT, XOR</h2>
<p>The previous operations are more like a whole operation on all the bits of the data. The AND, OR, NOT, XOR operations are more like the operations on the individual bits of the data. Because each result bit is determined by the corresponding bits of the operands, won't affect the bits on the other positions.</p>
<p>Here's some examples of the bitwise operations:</p>
<ul>
<li>
<p>Bitwise AND:</p>
<p><code>10101010</code> and <code>11001100</code> to <code>10001000</code></p>
</li>
<li>
<p>Bitwise OR:</p>
<p><code>10101010</code> and <code>11001100</code> to <code>11101110</code></p>
</li>
<li>
<p>Bitwise XOR:</p>
<p><code>10101010</code> and <code>11001100</code> to <code>01100110</code></p>
</li>
<li>
<p>Bitwise NOT:</p>
<p><code>10101010</code> to <code>01010101</code></p>
</li>
</ul>
<p>Here's the truth table of the bitwise operations:</p>
<table>
<thead>
<tr>
<th style="text-align:center">a</th>
<th style="text-align:center">b</th>
<th style="text-align:center">a AND b</th>
<th style="text-align:center">a OR b</th>
<th style="text-align:center">a XOR b</th>
<th style="text-align:center">NOT a</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<h1 id="Instructions-of-Making-Decisions">Instructions of Making Decisions</h1>
<h2 id="Conditional">Conditional</h2>
<p>What distinguishes a computer from a simple calculator is its ability to make decisions according to the result of the computation.</p>
<p>RISC-V instruction set provides two instructions to make decisions: <code>beq</code> and <code>bne</code>, which represent the <em>branch if equal</em> and <em>branch if not equal</em> respectively. These two instructions are traditionally called the <em>conditional branches</em>.</p>
<p>The first instruction <code>beq</code> used like this:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beq x1, x2, L1</span><br></pre></td></tr></table></figure>
<p>This instruction means that if the value of <code>x1</code> is equal to the value of <code>x2</code>, then the program will jump to the statement labeled <code>L1</code>.</p>
<p><code>bne</code> instruction simply means jump when not equal.</p>
<p>Here's a compiling example of the C code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == j)</span><br><span class="line">    f = g + h;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    f = g - h;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beq x1, x2, Else       // If i == j, go to Else</span><br><span class="line">add x3, x4, x5         // f = g + h</span><br><span class="line">beq x0, x0, Exit       // Go to Exit</span><br><span class="line">Else: sub x3, x4, x5   // f = g - h</span><br><span class="line">Exit:</span><br></pre></td></tr></table></figure>
<h2 id="Loops">Loops</h2>
<p>RISC-V instruction set don't have a specific instruction to perform the loops. But we can use the conditional branches to perform the loops, since loop is just keep jumping back to the same statement.</p>
<p>Here's two compiling example of the C code:</p>
<ul>
<li>
<p>While loop:</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    f = f + g;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Loop: blt x1, x2, Exit   // If i &lt; j, go to Exit</span><br><span class="line">add x3, x3, x4           // f = f + g</span><br><span class="line">beq x0, x0, Loop         // Go to Loop</span><br><span class="line">Exit:</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>For loop:</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    f = f + g;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">li x1, 0                  // i = 0</span><br><span class="line">Loop: bge x1, 10, Exit    // If i &gt;= 10, go to Exit</span><br><span class="line">add x3, x3, x4            // f = f + g</span><br><span class="line">addi x1, x1, 1            // i = i + 1</span><br><span class="line">beq x0, x0, Loop          // Go to Loop</span><br><span class="line">Exit:</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Such sequences of instructions that end in a conditional branch are called <em>basic blocks</em>. The basic blocks are the building blocks of the control flow of the program. One of the first early phases of compilation is to identify the basic blocks of the program.</p>
<h2 id="Boundary-Checking-Shortcut">Boundary Checking Shortcut</h2>
<p>The RISC-V instruction set also provides more conditional branches to make decisions. The <code>blt</code>, <code>bge</code>, <code>bltu</code>, <code>bgeu</code> instructions represent the <em>branch if less than</em>, <em>branch if greater than or equal</em>, <em>branch if less than unsigned</em>, and <em>branch if greater than or equal unsigned</em> respectively.</p>
<p>Since we already know the number representaion of the signed and unsigned numbers, we can image tha the way to compare the signed and unsigned numbers are different. However, this dosen't means that we can not use unsigned comparison to compare the signed numbers. And this actually offers a shortcut for boundary checking.</p>
<p>For a unsigned comparison, it's clear that we just need to compare the two numbers' binary code directly, like whose leftmost <code>1</code> is more left. As the signed number use the leftmost bit to represent the sign, which means negative numbers will always lager than any non-negative numbers if we use the unsigned comparison. And for a Boundary checking, we happens to need to check if a number is non-negative and less than a specific positive number. So we can use the unsigned comparison to perform the boundary checking.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgeu x20, x11, IndexOutOfBounds // If x20 &gt;= x11 or x20 &lt; 0, go to IndexOutOfBounds</span><br></pre></td></tr></table></figure>
<h2 id="Case-Switch-Statement">Case/Switch Statement</h2>
<p>Most programming languages provide a <code>case</code> or <code>switch</code> statement that allows the programmer to select one of many branches based on the value of an expression. A simple way to implement this feature in is to turn the <code>case</code> statement into a series of <code>if</code> statements.</p>
<p>But the alternative way may be more efficient. The RISC-V instruction set provides the <code>jalr</code> instruction (<em>jump and link register</em>), which is used to jump to a specific statement with no condition. By encoding the selectable branches' addresses into a table and load the address we want into a register, we can use the <code>jalr</code> instruction to jump to that specific address. The table is called a <em>branch address table</em> or <em>branch table</em>.</p>
<h1 id="Supporting-Procedures-in-Computer-Hardware">Supporting Procedures in Computer Hardware</h1>
<p>A <em>procedure</em> is a sequence of instructions that can solve a specific problem, which is suitable for reuse. In programming languages, a procedure has a more familiar name: <em>function</em>.</p>
<h2 id="What-will-a-Procedure-Do">What will a Procedure Do?</h2>
<p>RISC-V don't have specific instructions to support the procedures, but the reason it doesn't have is that the procedures are supported by the combination of the basic operations and the conditional branches. <strong>We can implement the concept of procedure abstractly</strong>.</p>
<p>All of us are very skilled at high-level programming using functions. Since procedure are just an alias of the function, we can directly describe some features of the procedure:</p>
<ul>
<li>
<p>Taking parameters as input.</p>
</li>
<li>
<p>Returning a result as output.</p>
</li>
<li>
<p>The procedure can be called in the main program.</p>
</li>
<li>
<p>The procedure can call other procedures.</p>
</li>
</ul>
<p>Now, as we've known the basics of assembly language, how we exactly do to implement the procedures using the assembly language? Well, in the execution of a procedure, the assembly program must follow these six steps:</p>
<ol>
<li>
<p>Put parameters in a place where the procedure can access them.</p>
</li>
<li>
<p>Transfer control to the procedure.</p>
</li>
<li>
<p>Acquire the storage resources needed for the procedure.</p>
</li>
<li>
<p>Perform the desired task.</p>
</li>
<li>
<p>Put the result value in a place where the calling program can access it.</p>
</li>
<li>
<p>Return control to the point of origin, since a procedure can be called from several points in a program.</p>
</li>
</ol>
<h2 id="How-procedure-abstractly-implemented">How procedure abstractly implemented?</h2>
<h3 id="Sharing-the-Registers">Sharing the Registers</h3>
<p>Recall that, we implement procedures in an abstract way. Why we call it abstract?</p>
<p>In the high-level programming, we consider the procedure has its own memory space.   we call functions in high-level programming, except we passed pointers as the parameters, we won't worry about the function changes the things &quot;outside&quot; the function. This is because the main memory is big enough to sperate the memory spaces.</p>
<p>But in RISC-V, we are persuing using registers as much as possible, and the registers are very limited, just exactly 32 registers in total and 64bits large per register.</p>
<p>Thus, when the caller calls a procedure, the caller will lose the control of the registers. After the calling, all the registers turn to serve the callee.</p>
<h3 id="Communicating-between-the-Caller-and-the-Callee">Communicating between the Caller and the Callee</h3>
<p>Then how caller and callee communicate? In the high-level programming, the caller and callee communicate through the parameters and the return value. In RISC-V, we follow a convention, or could be called a protocol, to let the caller and callee communicate. Just as the six steps we mentioned above, before the caller calls the callee, the caller will put the parameters in the specific registers, and after the callee returns, the callee will put the return value in the specific registers.</p>
<p>By convention, we use:</p>
<ul>
<li><code>x10</code> to <code>x17</code> as the parameter registers.</li>
<li><code>x1</code> to store the address of the next instruction after the jump instruction (for calling procedure) made by the caller.</li>
</ul>
<h3 id="Saving-and-Restoring-the-States-of-the-Registers">Saving and Restoring the States of the Registers</h3>
<p>Communicating issue solved, but not only caller need the return value, after the control back, we need to restore states of the registers for the continuation of the caller's execution. So the callee should also save the states of the registers before it uses the registers, and restore the states of the registers before return.</p>
<p>But now we have a new problem, to store the states of the registers, we need to transfer them into main memory and tansferring data between the memory and the registers is very slow. If this transfer happens frequently, the performance of the program will be very low. How to solve this problem? We can add some new rules to the protocol, like the callee can use some specific registers without saving the states, while some other registers must be saved before use and restored before return.</p>
<p>By convention, we use:</p>
<ul>
<li><code>x5</code> to <code>x7</code> and <code>x28</code> to <code>x31</code> as temporary registers that are not preserved by the callee on a procedure call.</li>
<li><code>x8</code> to <code>x9</code> and <code>x18</code> to <code>x27</code> as saved registers that must be preserved on a procedure call.</li>
</ul>
<h3 id="Datas-in-the-main-memory">Datas in the main memory</h3>
<p>As said above, we need to store some data in the main memory. If all the procedures won't call another procedure, which we call a <em>leaf procedure</em>, life will be much easier.</p>
<p>But it turns out that even the simplest program that print out <code>&quot;Hello, World!&quot;</code> coded in C will call tons of procedures. This leads to so many data transfer between the memory and the registers, and the data we stored in main memory contains the varibles of many different precedures.</p>
<p>Now the question is, how we determine the address of the data stored in or loaded from the main memory? Besides, we also need a way to distinguish the data of different procedures in the main memory.</p>
<p>Recall that in C, one function could only access the variables in the function itself except the global variables. These variables are called the <em>local variables</em>. The local variables were wrapped up by a concept called <em>frame</em>. One frame contains the local variables of a called function. As one function calls another function, new frames are generated. We put these frames in the main memory together, and call these bunch of frames the <em>stack</em>.</p>
<p>To effectively manage data in main memory when using assembly language, <strong>especially when dealing with nested or recursive procedure calls</strong>, the concepts of the stack and frame are crucial. These concepts not only help in distinguishing the data of different procedures but also streamline the process of storing and retrieving procedure-specific data.</p>
<h3 id="The-Stack">The Stack</h3>
<p>The stack is a structured portion of the computer's main memory used for storing temporary data such as procedure parameters, return addresses, and local variables. It operates on a Last In, First Out (LIFO) principle, meaning that the last piece of data pushed onto the stack will be the first one to be popped off. This structure is particularly useful for managing data in nested procedure calls, as it ensures that each procedure call has access to its own set of data without interfering with others.</p>
<p>When a procedure is called, a new block of memory on the stack, <strong>known as a stack frame or activation record</strong>, is allocated for that procedure. This stack frame contains all the necessary information for the procedure, including its parameters, local variables, and the return address. Once the procedure completes its execution and returns, its stack frame is deallocated, and control is handed back to the calling procedure, which resumes execution right where it left off.</p>
<h3 id="The-Frame">The Frame</h3>
<p>A frame, or an activation record, is a specific section of the stack allocated for a single execution of a procedure. The frame includes several key components:</p>
<ul>
<li><strong>Parameters</strong>: The values passed to the procedure upon calling.</li>
<li><strong>Return Address</strong>: The point in the program to return to once the procedure execution is completed.</li>
<li><strong>Saved Registers</strong>: Registers that need to be preserved across procedure calls, as per the calling convention, are saved here.</li>
<li><strong>Local Variables</strong>: Variables that are declared within the scope of the procedure.</li>
<li><strong>Temporary Data</strong>: Space for data that is temporarily needed during the execution of the procedure.</li>
</ul>
<p>The layout of a frame is determined by the calling convention used by the system, which dictates how parameters are passed, where the return address is stored, and which registers are saved.</p>
<h3 id="Managing-the-Stack-and-Frame">Managing the Stack and Frame</h3>
<p>To manage the stack and frames, the RISC-V architecture (like many other architectures) uses a pair of registers:</p>
<ul>
<li><strong>Stack Pointer (SP)</strong>: This pointer points to the top of the stack. It is automatically updated as data is pushed to or popped from the stack. In RISC-V, <code>x2</code> is often used as the stack pointer.</li>
<li><strong>Frame Pointer (FP)</strong>: This <strong>optional</strong> pointer <strong>always</strong> points to the base of the current stack frame, making it easier to access the frame's components. While not always necessary, using a frame pointer can simplify the code for accessing local variables and parameters, especially in deeply nested calls or when frames have variable sizes. Typically, <code>x8</code> is used as the frame pointer.</li>
</ul>
<p>When a procedure is called, the stack pointer is adjusted to allocate space for the new frame. The procedure's parameters, return address, and any necessary saved registers are then stored in this new frame. Upon completion of the procedure, the saved registers are restored, the return address is used to jump back to the calling procedure, and the stack pointer is adjusted to deallocate the frame.</p>
<p>This structured approach allows for efficient, organized management of procedure calls and returns, especially in complex programs with many nested procedure calls. It ensures that each procedure has access to its own data and resources, while maintaining the integrity and continuity of the program's execution flow.</p>
<p>Here's are two example of precudure and nested procedure's assembly code:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">add_numbers:</span><br><span class="line">    // Prologue</span><br><span class="line">    addi sp, sp, -16   // Allocate space on the stack for 2 words (16 bytes)</span><br><span class="line">    sd ra, 8(sp)       // Save the return address on the stack</span><br><span class="line">    sd s0, 0(sp)       // Save the frame pointer (s0) on the stack</span><br><span class="line">    addi s0, sp, 16    // Set up the new frame pointer</span><br><span class="line"></span><br><span class="line">    // Function body</span><br><span class="line">    add a0, a0, a1     // Perform the addition; result is in a0</span><br><span class="line"></span><br><span class="line">    // Epilogue</span><br><span class="line">    ld ra, 8(sp)       // Restore the return address from the stack</span><br><span class="line">    ld s0, 0(sp)       // Restore the frame pointer (s0) from the stack</span><br><span class="line">    addi sp, sp, 16    // Deallocate space on the stack</span><br><span class="line">    ret                // Return to caller</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">factorial:</span><br><span class="line">    addi sp, sp, -16   // Allocate space on the stack for 2 words (16 bytes)</span><br><span class="line">    sd ra, 8(sp)       // Save the return address on the stack</span><br><span class="line">    sd a0, 0(sp)       // Save the argument a0 on the stack since we&#x27;ll call this function recursively</span><br><span class="line"></span><br><span class="line">    // Base case: if n &lt;= 1, return 1</span><br><span class="line">    li t0, 1           // Load immediate value 1 into temporary register t0</span><br><span class="line">    ble a0, t0, end_recursion // If a0 &lt;= 1, jump to end_recursion</span><br><span class="line"></span><br><span class="line">    // Recursive case: n * factorial(n-1)</span><br><span class="line">    addi a0, a0, -1    // Decrement n by 1</span><br><span class="line">    jal ra, factorial  // Recursive call to factorial with n-1</span><br><span class="line"></span><br><span class="line">    // After returning from recursion, multiply n by the result</span><br><span class="line">    ld a0, 0(sp)       // Restore the original value of n</span><br><span class="line">    mul a0, a0, a1     // Multiply n by factorial(n-1), result is in a0</span><br><span class="line"></span><br><span class="line">end_recursion:</span><br><span class="line">    li a0, 1           // If we hit the base case, set result to 1</span><br><span class="line">    ld ra, 8(sp)       // Restore the return address from the stack</span><br><span class="line">    addi sp, sp, 16    // Deallocate space on the stack</span><br><span class="line">    ret                // Return to caller</span><br></pre></td></tr></table></figure>
<h3 id="Heap">Heap</h3>
<p>Corresponding to the stack, the concept of <em>heap</em> may also be familiar to you. Heap is also a data structure, but the concept here is not about the data structure, but the memory management.</p>
<p>Up to now, all we stored in the main memory are static data, which means the size of the data is determined when we write the program. But in the real world, we often need to store the data whose size is determined when the program is running. This kind of data is called the <em>dynamic data</em>. The dynamic data is stored in the heap.</p>
<p>When using stack pointer, the original stack pointer stores the address of the top address table of the main memory. When we want to allocate space for a new frame, we need to move down the stack pointer, i.e. subtract the stack pointer.</p>
<p>In the contrary, the address allocated for the dynamic data in the heap is always increasing.</p>
<h2 id="Global">Global</h2>
<p>A C variable is generally a location in storage, and its interpretation depends both on its type and storage class. C has two storage classes: automatic and static. Automatic variables are local to a procedure and are discarded when the procedure exits. Static variables exist across exits from and entries to procedures. C variables declared outside all procedures are considered static, as are any variables declared using the keyword static. The rest are automatic. To simplify access to static data, some RISC-V compilers reserve a register <code>x3</code> for use as the* global pointer*, or <code>gp</code>.</p>
<h2 id="Full-Calling-Convention">Full Calling Convention</h2>
<p>Finally, we've introduced all the key concepts when we implement the procedures in the assembly language. Now we can summarize the full calling convention of the RISC-V instruction set:</p>
<ol>
<li>
<p><strong>Parameter Passing</strong>: Parameters are passed in registers <code>x10</code> to <code>x17</code>. If there are more than 8 parameters, the remaining parameters are passed on the stack.</p>
</li>
<li>
<p><strong>Return Value</strong>: The return value is passed in register <code>x10</code>.</p>
</li>
<li>
<p><strong>Saved Registers</strong>: Registers <code>x8</code> to <code>x9</code> and <code>x18</code> to <code>x27</code> must be saved by the callee if they are used.</p>
</li>
<li>
<p><strong>Temporary Registers</strong>: Registers <code>x5</code> to <code>x7</code> and <code>x28</code> to <code>x31</code> can be used by the callee without saving their states.</p>
</li>
<li>
<p><strong>Stack Pointer</strong>: Register <code>x2</code> is used as the stack pointer.</p>
</li>
<li>
<p><strong>Frame Pointer</strong>: Register <code>x8</code> is used as the frame pointer, but it is optional.</p>
</li>
<li>
<p><strong>Return Address</strong>: The return address is stored in register <code>x1</code>.</p>
</li>
<li>
<p><strong>Zero</strong>: Register <code>x0</code> is hardwired to the value <code>0</code>.</p>
</li>
</ol>
<p>But if we always need to remember these rules, it will be very hard to write the assembly code. Thus, like the pseudo-instructions that assembler can translate to the real instructions, <strong>we can also use the <em>nick name</em> (formally <em>ABI Name</em>) of those registers to represent the registers.</strong> Here's a table shows the nick names of the registers:</p>
<table>
<thead>
<tr>
<th>Register</th>
<th>ABI Name</th>
<th>Description</th>
<th>Saver</th>
</tr>
</thead>
<tbody>
<tr>
<td>x0</td>
<td>zero</td>
<td>Hard-wired zero</td>
<td></td>
</tr>
<tr>
<td>x1</td>
<td>ra</td>
<td>Return address</td>
<td>Caller</td>
</tr>
<tr>
<td>x2</td>
<td>sp</td>
<td>Stack pointer</td>
<td>Callee</td>
</tr>
<tr>
<td>x3</td>
<td>gp</td>
<td>Global pointer</td>
<td></td>
</tr>
<tr>
<td>x4</td>
<td>tp</td>
<td>Thread pointer</td>
<td></td>
</tr>
<tr>
<td>x5-x7</td>
<td>t0-t2</td>
<td>Temporaries</td>
<td>Caller</td>
</tr>
<tr>
<td>x8</td>
<td>s0/fp</td>
<td>Saved register/frame pointer</td>
<td>Callee</td>
</tr>
<tr>
<td>x9</td>
<td>s1</td>
<td>Saved register</td>
<td>Callee</td>
</tr>
<tr>
<td>x10-x17</td>
<td>a0-a7</td>
<td>Function arguments/return values</td>
<td>Caller</td>
</tr>
<tr>
<td>x18-x27</td>
<td>s2-s11</td>
<td>Saved registers</td>
<td>Callee</td>
</tr>
<tr>
<td>x28-x31</td>
<td>t3-t6</td>
<td>Temporaries</td>
<td>Caller</td>
</tr>
</tbody>
</table>
<h1 id="RISC-V-Addressing-for-Wide-Immediates-and-Addresses">RISC-V Addressing for Wide Immediates and Addresses</h1>
<hr>
<h1 id="Unfinished-yet">Unfinished yet...</h1>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/CS110/" rel="tag"># CS110</a>
              <a href="/tags/%E4%B8%8A%E7%A7%91%E5%A4%A7/" rel="tag"># 上科大</a>
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/" rel="tag"># 计算机体系架构</a>
              <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"># 笔记</a>
              <a href="/tags/Unfinished/" rel="tag"># Unfinished</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2024/02/23/CS110/CS110-Note-2/" rel="prev" title="CS110 Note [2]">
      <i class="fa fa-chevron-left"></i> CS110 Note [2]
    </a></div>
      <div class="post-nav-item">
    <a href="/%E7%BB%8F%E9%AA%8C/2024/03/24/Refs/Docker-Engine-Proxy-Set-up/" rel="next" title="Docker Engine Proxy Set up">
      Docker Engine Proxy Set up <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Operations-of-the-Computer-Hardware"><span class="nav-number">1.</span> <span class="nav-text">Operations of the Computer Hardware</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Instruction-set"><span class="nav-number">1.1.</span> <span class="nav-text">Instruction set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Assembly-Language"><span class="nav-number">1.2.</span> <span class="nav-text">Assembly Language</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Operands-of-the-Computer-Hardware"><span class="nav-number">2.</span> <span class="nav-text">Operands of the Computer Hardware</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Register-Operands"><span class="nav-number">2.1.</span> <span class="nav-text">Register Operands</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Memory-Operands"><span class="nav-number">2.2.</span> <span class="nav-text">Memory Operands</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Constant-or-Imemdiate-Operands"><span class="nav-number">2.3.</span> <span class="nav-text">Constant or Imemdiate Operands</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Representing-Instructions-in-the-Computer"><span class="nav-number">3.</span> <span class="nav-text">Representing Instructions in the Computer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Machine-Language"><span class="nav-number">3.1.</span> <span class="nav-text">Machine Language</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Instruction-Formats"><span class="nav-number">3.2.</span> <span class="nav-text">Instruction Formats</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Big-Picture"><span class="nav-number">3.3.</span> <span class="nav-text">The Big Picture</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Logical-Operations"><span class="nav-number">4.</span> <span class="nav-text">Logical Operations</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Bitwise-Operations"><span class="nav-number">4.1.</span> <span class="nav-text">Bitwise Operations</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shift-Operations"><span class="nav-number">4.2.</span> <span class="nav-text">Shift Operations</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AND-OR-NOT-XOR"><span class="nav-number">4.3.</span> <span class="nav-text">AND, OR, NOT, XOR</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Instructions-of-Making-Decisions"><span class="nav-number">5.</span> <span class="nav-text">Instructions of Making Decisions</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Conditional"><span class="nav-number">5.1.</span> <span class="nav-text">Conditional</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Loops"><span class="nav-number">5.2.</span> <span class="nav-text">Loops</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Boundary-Checking-Shortcut"><span class="nav-number">5.3.</span> <span class="nav-text">Boundary Checking Shortcut</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Case-Switch-Statement"><span class="nav-number">5.4.</span> <span class="nav-text">Case&#x2F;Switch Statement</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Supporting-Procedures-in-Computer-Hardware"><span class="nav-number">6.</span> <span class="nav-text">Supporting Procedures in Computer Hardware</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#What-will-a-Procedure-Do"><span class="nav-number">6.1.</span> <span class="nav-text">What will a Procedure Do?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#How-procedure-abstractly-implemented"><span class="nav-number">6.2.</span> <span class="nav-text">How procedure abstractly implemented?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Sharing-the-Registers"><span class="nav-number">6.2.1.</span> <span class="nav-text">Sharing the Registers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Communicating-between-the-Caller-and-the-Callee"><span class="nav-number">6.2.2.</span> <span class="nav-text">Communicating between the Caller and the Callee</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Saving-and-Restoring-the-States-of-the-Registers"><span class="nav-number">6.2.3.</span> <span class="nav-text">Saving and Restoring the States of the Registers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Datas-in-the-main-memory"><span class="nav-number">6.2.4.</span> <span class="nav-text">Datas in the main memory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Stack"><span class="nav-number">6.2.5.</span> <span class="nav-text">The Stack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Frame"><span class="nav-number">6.2.6.</span> <span class="nav-text">The Frame</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Managing-the-Stack-and-Frame"><span class="nav-number">6.2.7.</span> <span class="nav-text">Managing the Stack and Frame</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Heap"><span class="nav-number">6.2.8.</span> <span class="nav-text">Heap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Global"><span class="nav-number">6.3.</span> <span class="nav-text">Global</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Full-Calling-Convention"><span class="nav-number">6.4.</span> <span class="nav-text">Full Calling Convention</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RISC-V-Addressing-for-Wide-Immediates-and-Addresses"><span class="nav-number">7.</span> <span class="nav-text">RISC-V Addressing for Wide Immediates and Addresses</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Unfinished-yet"><span class="nav-number">8.</span> <span class="nav-text">Unfinished yet...</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zivmax"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Zivmax</p>
  <div class="site-description" itemprop="description">记录我在 STU 的所见所闻,以及成长</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">73</span>
          <span class="site-state-item-name">日志</span>
          
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zivmax" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zivmax" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:marsh.mallow@foxmail.com" title="E-Mail → mailto:marsh.mallow@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/wechat/" title="Wechat → &#x2F;wechat&#x2F;"><i class="fab fa-weixin fa-fw"></i>Wechat</a>
      </span>
      <span class="links-of-author-item">
        <a href="/QQ/" title="QQ → &#x2F;QQ&#x2F;"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
          
        </div>
  
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-8-11 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-flag"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zivmax</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>




        








      </div>
    </footer>
  </div>

  
  <script color='255,255,255' opacity='0.8' zIndex='-1' count='120' src="/lib/canvas-nest/canvas-nest-nomobile.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">
  <script src="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.js"></script>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.css">


  

    </div>


</body>
</html>

