<!DOCTYPE html>
<html lang="zh-CN,en,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/soundwave.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/soundwave.svg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/soundwave.svg">
  <link rel="mask-icon" href="/images/soundwave.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zivmax.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="注意：本学期 CS101 PA 的所有 C++ 代码都采用 C++20 标准。如果您使用 GCC 或 Clang，您需要在编译时设置 -std&#x3D;c++20 。">
<meta property="og:type" content="article">
<meta property="og:title" content="CS101 PA [1]">
<meta property="og:url" content="https://zivmax.top/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2024/01/26/CS101-PA-1/index.html">
<meta property="og:site_name" content="青山后小塘">
<meta property="og:description" content="注意：本学期 CS101 PA 的所有 C++ 代码都采用 C++20 标准。如果您使用 GCC 或 Clang，您需要在编译时设置 -std&#x3D;c++20 。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zivmax.top/img/begin_end.png">
<meta property="article:published_time" content="2024-01-26T02:17:23.000Z">
<meta property="article:modified_time" content="2024-03-26T03:19:50.751Z">
<meta property="article:author" content="Zivmax">
<meta property="article:tag" content="作业">
<meta property="article:tag" content="上科大">
<meta property="article:tag" content="CS110">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zivmax.top/img/begin_end.png">

<link rel="canonical" href="https://zivmax.top/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2024/01/26/CS101-PA-1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>CS101 PA [1] | 青山后小塘</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  <!-- require APlayer -->
  <link rel="stylesheet" href="/dist/APlayer.min.css"media="all">
  <div id="aplayer"></div>
  <script src="/dist/APlayer.min.js"></script>
  <!-- require MetingJS -->
  <script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
<link rel="alternate" href="/atom.xml" title="青山后小塘" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">

  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">青山后小塘</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">人生如逆旅，我亦是行人</p>
      <a>
        <img class="custom-logo-image" src="/uploads/cib-boeing.svg" alt="青山后小塘">
      </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">37</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">70</span></a>

  </li>
        <li class="menu-item menu-item-playlist">

    <a href="/playlist/" rel="section"><i class="fa fa-music fa-fw"></i>歌单</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zivmax.top/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2024/01/26/CS101-PA-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zivmax">
      <meta itemprop="description" content="记录我在 STU 的所见所闻,以及成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青山后小塘">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CS101 PA [1]
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间: 2024-01-26 10:17:23" itemprop="dateCreated datePublished" datetime="2024-01-26T10:17:23+08:00">2024-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间: 2024-03-26 11:19:50" itemprop="dateModified" datetime="2024-03-26T11:19:50+08:00">2024-03-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数: </span>
              <span>30k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3:10</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>注意：本学期 CS101 PA 的所有 C++ 代码都采用 C++20 标准。如果您使用 GCC 或 Clang，您需要在编译时设置 <code>-std=c++20</code> 。</p>
<span id="more"></span>
<p>如果您看到类似这样的报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++-9: error: unrecognized command line option ‘-std=c++20’; did you mean ‘-std=c++2a’?</span><br></pre></td></tr></table></figure>
<p>说明您的编译器版本过低，请安装更高版本的编译器。目前 GCC 13 几乎已经将 C++20 除 modules 外的全部新特性实现完毕，我们推荐使用 GCC 13。</p>
<h1 id="Problem-1-Singly-linked-list">Problem 1. Singly-linked list</h1>
<p>本题采用中文描述。</p>
<h2 id="目录">目录</h2>
<ul>
<li><a href="#problem-1-singly-linked-list">Problem 1. Singly-linked list</a>
<ul>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
<li><a href="#%E5%BC%80%E5%A7%8B">开始</a></li>
<li><a href="#slistnode-%E7%B1%BB"><code>SlistNode</code> 类</a></li>
<li><a href="#slistiterator-%E7%B1%BB"><code>SlistIterator</code> 类</a></li>
<li><a href="#slist-%E7%B1%BB"><code>Slist</code> 类</a>
<ul>
<li><a href="#slist-%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><code>Slist</code> 的构造函数</a></li>
<li><a href="#slist-%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E6%88%90%E5%91%98"><code>Slist</code> 的拷贝控制成员</a></li>
<li><a href="#slist-%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><code>Slist</code> 的迭代器</a></li>
<li><a href="#slist-%E7%9A%84%E7%BB%B4%E6%8A%A4%E6%80%A7%E6%93%8D%E4%BD%9C"><code>Slist</code> 的维护性操作</a></li>
<li><a href="#slist-%E7%9A%84%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><code>Slist</code> 的比较运算符</a></li>
<li><a href="#%E7%89%B9%E6%AE%8A%E6%93%8D%E4%BD%9C">特殊操作</a></li>
</ul>
</li>
<li><a href="#%E5%BB%BA%E8%AE%AE%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F">建议实现顺序</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E7%82%B9%E4%BF%A1%E6%81%AF">测试点信息</a></li>
<li><a href="#%E9%99%84%E5%BD%95">附录</a>
<ul>
<li><a href="#requirementscpp"><code>requirements.cpp</code></a></li>
<li><a href="#stdunique_ptr"><code>std::unique_ptr</code></a></li>
<li><a href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91">完美转发</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#problem-2-hash-table">Problem 2. Hash Table</a>
<ul>
<li><a href="#hash-function">Hash Function</a></li>
<li><a href="#hash-table">Hash Table</a></li>
</ul>
</li>
<li><a href="#problem-3-quick-sort">Problem 3. Quick Sort</a>
<ul>
<li><a href="#requirements">Requirements:</a></li>
</ul>
</li>
<li><a href="#%E8%AF%84%E5%88%86">评分</a></li>
</ul>
<h2 id="开始">开始</h2>
<p>在本题中，您需要按照 C++ STL 容器的规范实现一个模板化的链表类 <code>Slist</code> 及其迭代器 <code>SlistIterator</code> 。</p>
<p>首先，请去 Piazza Resources 下载本题所需的文件。下发的文件结构如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── attachments/</span><br><span class="line">    ├── tests/</span><br><span class="line">    │   ├── assignments.cpp</span><br><span class="line">    │   ├── begin_end.cpp</span><br><span class="line">    │   ├── constructors.cpp</span><br><span class="line">    │   ├── emplace_after.cpp</span><br><span class="line">    │   ├── erase_after.cpp</span><br><span class="line">    │   ├── front.cpp</span><br><span class="line">    │   ├── insert_after.cpp</span><br><span class="line">    │   ├── merge.cpp</span><br><span class="line">    │   ├── no_copy_or_move_type.cpp</span><br><span class="line">    │   ├── only_copy_constructible_type.cpp</span><br><span class="line">    │   ├── size_empty.cpp</span><br><span class="line">    │   └── sort.cpp</span><br><span class="line">    ├── requirements.cpp</span><br><span class="line">    ├── slist_node.hpp</span><br><span class="line">    └── slist.hpp</span><br></pre></td></tr></table></figure>
<p>其中，<code>slist.hpp</code> 是您需要完成和提交的文件，这里包含了链表的迭代器类 <code>SlistIterator</code> 和链表类 <code>Slist</code> 的定义，并且 <code>#include</code> 了 <code>slist_node.hpp</code> 。 <code>slist_node.hpp</code> 里定义了链表的结点类 <code>SlistNode</code> ，您不能修改这部分代码，也不需要提交这个文件，我们会在 OJ 上提供。</p>
<p>当您写完代码之后，您可以编译 <code>requirements.cpp</code> 来对您的链表和迭代器的各个接口作初步的检验（阅读<a href="#requirementscpp">附录-<code>requirements.cpp</code></a>来获取关于这个文件的详细解释）。注意，我们已经将您需要写的所有函数声明正确地给出来了，所以在您什么都没写的时候 <code>requirements.cpp</code> 应当是能编译通过的。</p>
<p><code>tests/</code> 文件夹下是我们提供的一些简单的测试程序，基本覆盖了您要实现的全部功能。这些代码大多数来自于 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/container/forward_list">cppreference <code>forward_list</code></a> 文档里的 examples ，当然也有一些是我们单独提供的（如 <code>no_copy_or_move_type.cpp</code> ）。我们强烈建议您在提交之前先过一遍这里的测试程序，并且有针对性地编写一些额外的测试。我们不提供这些测试程序的正确输出结果，因为它们都非常简单，您应当有能力判断其正确性。</p>
<p>下面我将完整地向您介绍这个程序里的每一段代码。<strong>注意，我们建议您按照<a href="#%E5%BB%BA%E8%AE%AE%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F">这一节</a>所写的顺序来完成本题的各个函数，而不是按照下面的介绍顺序。</strong></p>
<h2 id="SlistNode-类"><code>SlistNode</code> 类</h2>
<p>链表的结点类 <code>SlistNode</code> 定义在文件 <code>slist_node.hpp</code> 中。</p>
<p>这是一个类模板，模板参数 <code>T</code> 表示链表的结点上存储的元素的类型。链表的结点包含两样东西：</p>
<ol>
<li>指向下一个结点的指针 <code>next</code> ，类型为 <code>std::unique_ptr&lt;SlistNode&lt;T&gt;&gt;</code> ；</li>
<li>当前结点所存储的元素 <code>value</code> ，类型为 <code>T</code> 。</li>
</ol>
<p>如果您不清楚什么是 <code>std::unique_ptr</code> ，请看<a href="#stdunique_ptr">附录-<code>std::unique_ptr</code></a>。</p>
<p><code>SlistNode</code> 定义了一个构造函数，它接受一个 <code>std::unique_ptr&lt;T&gt; &amp;&amp;</code> 类型的参数 <code>nxt</code> 和一串任意类型的参数 <code>args...</code> ，用 <code>std::move(nxt)</code> 初始化 <code>next</code> ，并将 <code>args...</code> 完美转发给 <code>T</code> 类型的构造函数来初始化 <code>value</code> 。由于 <code>std::unique_ptr</code> 是 move-only type ，我们必须用这种方式（这也是最好的方式）来初始化 <code>next</code> 成员。如果您不清楚什么是完美转发，请看<a href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91">附录-完美转发</a>。</p>
<p>注意，由于 <code>SlistNode</code> 有一个 user-provided constructor ，编译器不会为它合成 default constructor 。又因为它有一个不可拷贝的 <code>std::unique_ptr&lt;SlistNode&lt;T&gt;&gt;</code> 类型的成员，它的 copy constructor 和 copy assignment operator 都是不可用的（implicitly deleted）。<code>SlistNode</code> 是一个 move-only type ，请不要试图拷贝一个该类型的对象。</p>
<p>注意，您不能对链表结点所存储的元素类型 <code>T</code> 的特征作任何假定，它不一定能默认构造，不一定能拷贝，不一定能移动。</p>
<h2 id="SlistIterator-类"><code>SlistIterator</code> 类</h2>
<p><code>SlistIterator</code> 是链表的迭代器类，定义于 <code>slist.hpp</code> 中。</p>
<p>这是一个类模板，模板参数 <code>T</code> 表示链表的结点上存储的元素的类型，模板参数 <code>IsConst</code> 表示这个迭代器是不是 <em>constant iterator</em> 。相比于正常的迭代器，一个 <em>constant iterator</em> 不允许通过它修改它所指向的元素，比方说它的解引用运算符 <code>operator*()</code> 返回的是 <code>const T &amp;</code> 而非 <code>T &amp;</code> 。</p>
<p>按照 STL 的规范，一个迭代器通常需要声明以下五个类型别名成员（这里您只需要认识 <code>reference</code> ）：</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>含义</th>
<th><code>SlistIterator&lt;T, IsConst&gt;</code> 中的定义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>value_type</code></td>
<td>指向的元素的类型</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>difference_type</code></td>
<td>两个迭代器的距离的类型</td>
<td><code>std::ptrdiff_t</code></td>
</tr>
<tr>
<td><code>reference</code></td>
<td>对它所指向的元素的引用</td>
<td><code>IsConst</code> 为真时是 <code>const T &amp;</code> ，否则是 <code>T &amp;</code></td>
</tr>
<tr>
<td><code>pointer</code></td>
<td>指向它所指向的元素的指针</td>
<td><code>IsConst</code> 为真时是 <code>const T *</code> ，否则是 <code>T *</code></td>
</tr>
<tr>
<td><code>iterator_category</code></td>
<td>迭代器型别</td>
<td><code>std::forward_iterator_tag</code></td>
</tr>
</tbody>
</table>
<p>链表的迭代器内部持有一个指向结点的指针，名为 <code>m_node</code> 。这个指针只能是裸指针 <code>SlistNode&lt;T&gt; *</code> ，而非 <code>std::unique_ptr&lt;SlistNode&lt;T&gt;&gt;</code> ，因为它并不“拥有”它所指向的结点，仅仅是“观察”那个结点。它无权干涉结点的生命期。</p>
<p><code>SlistIterator&lt;T, IsConst&gt;</code> 的构造函数如下：</p>
<ol>
<li>
<p>默认构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SlistIterator</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
<p>它将 <code>m_node</code> 初始化为空指针 <code>nullptr</code> 。这样构造出的迭代器被用来表示“尾后”迭代器。<code>Slist&lt;T&gt;::end()</code> 返回的就是这样的迭代器。</p>
</li>
<li>
<p>接受一个指向结点的指针，表示这个迭代器应该指向的位置。为了方便，它接受 <code>std::unique_ptr</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">SlistIterator</span><span class="params">(<span class="type">const</span> std::unique_ptr&lt;SlistNode&lt;T&gt;&gt; &amp;up)</span></span></span><br><span class="line"><span class="function">    : m_node&#123;</span>up.<span class="built_in">get</span>()&#125; &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>允许“添加底层 <code>const</code> ”的类型转换，即允许用一个 <code>SlistIterator&lt;T, false&gt;</code> 构造一个 <code>SlistIterator&lt;T, true&gt;</code> 。您不需要理解这个函数（以及 <code>isAddingLowLevelConst</code> ）的实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Other&gt;</span><br><span class="line">  <span class="keyword">requires</span> isAddingLowLevelConst&lt;std::<span class="type">decay_t</span>&lt;Other&gt;&gt;</span><br><span class="line"><span class="built_in">SlistIterator</span>(Other &amp;&amp;other) : m_node&#123;other.<span class="built_in">base</span>()&#125; &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>SlistIterator&lt;T, IsConst&gt;</code> 具有编译器合成的 copy constructor 和 move constructor，它们的行为就是拷贝初始化 <code>m_node</code> ，是 trivial 的。</p>
</li>
</ol>
<p><code>SlistIterator&lt;T, IsConst&gt;</code> 还具有编译器合成的 copy assignment operator 和 move assignment operator ，它们的行为就是为 <code>m_node</code> 赋值，是 trivial 的。</p>
<p><code>SlistIterator&lt;T, IsConst&gt;::base()</code> 的作用是返回 <code>m_node</code> 的值，即它所指向的结点的地址。<strong>您会需要使用这个函数的。</strong></p>
<p>以下是您需要实现的成员函数。注：这部分非常简单，也和 CS101 课程内容没什么关系，仅仅是为了让您熟悉这个迭代器的使用和行为，以便后面实现 <code>Slist</code> 的相关操作时能更得心应手。</p>
<ol>
<li>
<p>解引用运算符，返回它所指向的<strong>元素</strong>（注意，不是“结点”）的引用。返回值类型为先前声明过的类型别名 <code>reference</code> ，即在 <code>IsConst</code> 为真时是 <code>const T &amp;</code> ，否则是 <code>T &amp;</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reference <span class="keyword">operator</span>*() <span class="type">const</span>;</span><br></pre></td></tr></table></figure>
<p>与之配套的箭头运算符 <code>operator-&gt;()</code> 已经实现好了。只要您的 <code>operator*()</code> 写对，就可以保证 <code>iter-&gt;mem</code> 总是等价于 <code>(*iter).mem</code> 。</p>
</li>
<li>
<p>前置递增运算符，让这个迭代器前进到下一个位置（即指向下一个元素），然后返回自身的引用（<code>*this</code>）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self_type &amp;<span class="keyword">operator</span>++();</span><br></pre></td></tr></table></figure>
<p>与之配套的后置递增运算符 <code>operator++(int)</code> 已经实现好了，它先为自身作一份拷贝，然后调用前置递增运算符前进到下一个位置，再返回那个拷贝。所以它返回的迭代器仍然指向递增前的位置。</p>
</li>
<li>
<p>相等运算符，判断两个迭代器是否指向同一个结点，也就是判断那两个结点的指针是否相等。注意，判断两个迭代器相等时，我们并不在乎它们是不是 constant iterator ，因此相等运算符是一个模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> C&gt; <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> SlistIterator&lt;T, C&gt; &amp;other) <span class="type">const</span>;</span><br></pre></td></tr></table></figure>
<p>与之配套的不相等运算符 <code>operator!=()</code> 会由编译器根据 C++20 的相关规则生成。</p>
</li>
</ol>
<h2 id="Slist-类"><code>Slist</code> 类</h2>
<p><code>Slist</code> 是单向链表类（Singly-linked list），定义于 <code>slist.hpp</code> 中。这是本题的核心。</p>
<p>这是一个类模板，模板参数 <code>T</code> 表示链表的结点上存储的元素的类型。<strong>注意，我们不能对 <code>T</code> 所具有的性质作任何假定，它不一定能默认构造，不一定能拷贝，不一定能移动。</strong> 某些特定的成员函数可能依赖于 <code>T</code> 的某些性质才能实现，我们会特别说明。</p>
<p>按照 STL 的规范，一个容器通常需要声明以下这些类型别名成员：</p>
<table>
<thead>
<tr>
<th>是否需要认识</th>
<th>名字</th>
<th>含义</th>
<th><code>Slist&lt;T&gt;</code> 中的定义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Yes</strong></td>
<td><code>value_type</code></td>
<td>链表所存储的元素的类型</td>
<td><code>T</code></td>
</tr>
<tr>
<td><strong>Yes</strong></td>
<td><code>size_type</code></td>
<td>适合表示链表的元素个数的类型</td>
<td><code>std::size_t</code></td>
</tr>
<tr>
<td>No</td>
<td><code>difference_type</code></td>
<td>适合表示两个迭代器的距离的类型</td>
<td><code>std::ptrdiff_t</code></td>
</tr>
<tr>
<td><strong>Yes</strong></td>
<td><code>reference</code></td>
<td>链表所存储的元素的类型的引用</td>
<td><code>T &amp;</code></td>
</tr>
<tr>
<td>No</td>
<td><code>const_reference</code></td>
<td>链表所存储的元素的类型的 <code>const</code> 引用</td>
<td><code>const T &amp;</code></td>
</tr>
<tr>
<td>No</td>
<td><code>pointer</code></td>
<td>链表所存储的元素的类型的指针</td>
<td><code>T *</code></td>
</tr>
<tr>
<td>No</td>
<td><code>const_pointer</code></td>
<td>链表所存储的元素的类型的 <code>const</code> 指针</td>
<td><code>const T *</code></td>
</tr>
<tr>
<td><strong>Yes</strong></td>
<td><code>iterator</code></td>
<td>迭代器</td>
<td><code>SlistIterator&lt;T, false&gt;</code></td>
</tr>
<tr>
<td><strong>Yes</strong></td>
<td><code>const_iterator</code></td>
<td>不可修改元素的迭代器 (constant iterator)</td>
<td><code>SlistIterator&lt;T, true&gt;</code></td>
</tr>
</tbody>
</table>
<p><code>Slist&lt;T&gt;</code> 有一个成员变量 <code>m_head</code> ，其类型为 <code>std::unique_ptr&lt;SlistNode&lt;T&gt;&gt;</code> ，它是指向链表的头结点的指针。除此之外，我们不存储其它变量，包括尾结点的指针、结点的数量等。再次强调，我们大量使用 <code>std::unique_ptr</code> ，如果您对于它还不熟悉，请先去看<a href="#stdunique_ptr">附录-<code>std::unique_ptr</code></a>熟悉一下。</p>
<h3 id="Slist-的构造函数"><code>Slist</code> 的构造函数</h3>
<p><code>Slist&lt;T&gt;</code> 的构造函数如下：</p>
<ol>
<li>
<p>默认构造函数，将 <code>m_head</code> 初始化为不持有任何对象的 <code>std::unique_ptr</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Slist</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>拷贝构造函数，接受一个参数 <code>const Slist &amp;other</code> ，将自身初始化为 <code>other</code> 的拷贝。<u><strong>这个函数假定 <code>T</code> 可以拷贝初始化。</strong></u></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Slist</span>(<span class="type">const</span> Slist &amp;other);</span><br></pre></td></tr></table></figure>
<p>每一个元素都被拷贝。拷贝构造结束后，这两个链表相互独立，对其中一个的修改不会作用于另一个上。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Slist&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">Slist&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a)</span></span>; <span class="comment">// copy construct from `a&#x27;</span></span><br><span class="line"><span class="comment">// Now the elements in `b&#x27; are &#123;1, 2, 3&#125;.</span></span><br><span class="line">b.<span class="built_in">front</span>() = <span class="number">4</span>;</span><br><span class="line">b.<span class="built_in">push_front</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// Now the elements in `b&#x27; are &#123;5, 4, 2, 3&#125;, while `a` is still &#123;1, 2, 3&#125;.</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>移动构造函数，接受一个参数 <code>Slist &amp;&amp;other</code> ，将 <code>other</code> 对其所存储的元素的所有权转移给自己。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Slist</span>(Slist &amp;&amp;other) <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
<p>此处的参数名 <code>other</code> 可以省略。</p>
</li>
<li>
<p>接受一个整数 <code>count</code> 和一个值 <code>value</code> ，将自身初始化为拥有 <code>count</code> 个元素的链表，每个元素都是 <code>value</code> 的拷贝。<u><strong>这个函数假定 <code>T</code> 可以拷贝初始化。</strong></u></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Slist</span>(size_type count, <span class="type">const</span> T &amp;value);</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Slist&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>; <span class="comment">// &#123;5, 5, 5&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>接受一个整数 <code>count</code> ，将自身初始化为拥有 <code>count</code> 个元素的链表，每个元素都被<em>值初始化（value-initialized）</em>。<u><strong>这个函数假定 <code>T</code> 可以默认初始化。</strong></u></p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Slist</span><span class="params">(size_type count)</span></span>;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Slist&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">// &#123;0, 0, 0&#125;</span></span><br><span class="line"><span class="function">Slist&lt;std::string&gt; <span class="title">b</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">// &#123;&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<p>不知道怎样值初始化这些元素？看<a href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91">附录-完美转发</a>。</p>
</li>
<li>
<p>接受一对 <em>InputIterator</em> 表示一个迭代器范围 <code>[b, e)</code> ，从这个迭代器范围中获得内容进行初始化。<u><strong>这个函数假定 <code>T</code> 可以从一个 <code>V</code> 类型的表达式初始化，其中 <code>V</code> 是该迭代器解引用的结果类型。</strong></u></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Slist</span>(std::input_iterator <span class="keyword">auto</span> b, std::input_iterator <span class="keyword">auto</span> e);</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector v&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">std::list l&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">56</span>&#125;;</span><br><span class="line"><span class="function">Slist&lt;<span class="type">int</span>&gt; <span class="title">sl1</span><span class="params">(v.begin(), v.end())</span></span>; <span class="comment">// &#123;3, 5, 6, 8&#125;</span></span><br><span class="line"><span class="function">Slist&lt;<span class="type">int</span>&gt; <span class="title">sl2</span><span class="params">(l.begin(), l.end())</span></span>; <span class="comment">// &#123;1, 2, 5&#125;</span></span><br><span class="line"><span class="function">Slist&lt;<span class="type">int</span>&gt; <span class="title">sl3</span><span class="params">(a + <span class="number">1</span>, a + <span class="number">3</span>)</span></span>; <span class="comment">// &#123;43, 44&#125;</span></span><br></pre></td></tr></table></figure>
<p>这段代码中， <code>Slist&lt;int&gt;</code> 都可以省略为 <code>Slist</code> ，这是因为在 <code>slist.hpp</code> 的最后我们提供了一份针对这个构造函数的 deduction guide 。</p>
<p>注意，这里对元素的初始化并不一定是拷贝，例如有一种所谓的<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/iterator/move_iterator">“移动迭代器”</a>，其解引用运算符会返回一个右值引用，使得元素有可能被移动：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Your implementation must allow this:</span></span><br><span class="line">std::vector&lt;std::unique_ptr&lt;<span class="type">int</span>&gt;&gt; v = <span class="built_in">something</span>();</span><br><span class="line">Slist&lt;std::unique_ptr&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">up</span>(std::<span class="built_in">make_move_iterator</span>(v.<span class="built_in">begin</span>()),</span><br><span class="line">                               std::<span class="built_in">make_move_iterator</span>(v.<span class="built_in">end</span>()));</span><br></pre></td></tr></table></figure>
<p>注意，这一对迭代器是 <em>InputIterator</em> ，意味着它不提供 multi-pass guarantee ：下面的断言是有可能失败的。也就是说，您不能反复获取 <code>[b, e)</code> 中已经获取过的元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> old_b = b;</span><br><span class="line"><span class="keyword">auto</span> old_value = *b;</span><br><span class="line">++b;</span><br><span class="line"><span class="built_in">assert</span>(*old_b == old_value); <span class="comment">// may fail for InputIterator `b&#x27;.</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>接受一个 <code>std::initializer_list&lt;T&gt;</code> 进行初始化。<u><strong>这个函数假定 <code>T</code> 可以拷贝初始化。</strong></u></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Slist</span>(std::initializer_list&lt;T&gt; init) : <span class="built_in">Slist</span>(init.<span class="built_in">begin</span>(), init.<span class="built_in">end</span>()) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Slist&lt;<span class="type">int</span>&gt; sl1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">Slist&lt;<span class="type">int</span>&gt; sl2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// equivalent way</span></span><br></pre></td></tr></table></figure>
<p>注意，这个函数的实现我们已经给出，它利用了 <code>std::initializer_list</code> 的迭代器，直接将工作转交给构造函数 6 。也许您可以从这之中获得一些启发，也用这样的方式实现某个构造函数，这样可以节省一些力气。</p>
</li>
</ol>
<p>以上构造函数中，您需要实现的有 2, 4, 5, 6 。注意，到目前为止我们还未介绍 <code>push_front</code>, <code>erase_after</code> 等修改操作，但并不意味着您在构造函数中不能调用它们。</p>
<h3 id="Slist-的拷贝控制成员"><code>Slist</code> 的拷贝控制成员</h3>
<p><code>Slist&lt;T&gt;</code> 具有全部五个拷贝控制成员：拷贝构造函数，拷贝赋值运算符，移动构造函数，移动赋值运算符，析构函数。其中，拷贝构造函数需要您实现（如上文所述），拷贝赋值运算符藉由 copy-and-swap 的方式实现，两个移动操作和析构函数直接由编译器生成。</p>
<p>这里值得一提的是析构函数的实现：编译器生成的析构函数会析构 <code>m_head</code> ，而它是一个 <code>std::unique_ptr</code> ，它的析构函数会析构它所指向的对象，也就是头结点；头结点的析构函数会析构头结点的 <code>next</code> 指针，这也是一个 <code>std::unique_ptr</code> ，因此第二个结点也会被析构，以此类推，最终所有结点都会被自动析构。</p>
<p>这个析构方式听起来很聪明，但它有一个问题：这一连串的析构是递归发生的，并且递归深度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 。一般来说，在实际应用中，特别是在编写库代码时，需要避免像这样的大量的递归，因为它容易造成栈空间不足而导致灾难。但是出于教学的目的，考虑到许多同学可能很少在代码中使用过递归，<strong>在本题中我们鼓励大家使用递归</strong>。如果您认为某个函数采用递归实现可以简化代码，就大胆地用吧。</p>
<h3 id="Slist-的迭代器"><code>Slist</code> 的迭代器</h3>
<p><code>Slist</code> 的一组 <code>begin</code> 、 <code>end</code> 函数已经给出，其中 <code>begin</code> 返回指向首元素的迭代器， <code>end</code> 返回指向“尾后”位置的迭代器，如图所示</p>
<p><img src="/img/begin_end.png" alt></p>
<p>为了简化问题，我们不要求像 <code>std::forward_list</code> 那样实现 <code>before_begin()</code> 。</p>
<h3 id="Slist-的维护性操作"><code>Slist</code> 的维护性操作</h3>
<ol>
<li>
<p><code>push_front</code> 和 <code>emplace_front</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">emplace_front</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(T &amp;&amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">emplace_front</span>(std::<span class="built_in">move</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function">reference <span class="title">emplace_front</span><span class="params">(Types &amp;&amp;...args)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这三个函数都在链表的头部插入一个结点，插入的新结点则成为新的头结点。 <code>push_front</code> 无返回值。 <code>emplace_front</code> 返回新创建的那个<strong>元素</strong>（注意，不是“结点”）的引用。</p>
<ul>
<li>第一个函数接受 <code>const T &amp;x</code> 参数，新结点的元素由 <code>x</code> 拷贝初始化。</li>
<li>第二个函数接受 <code>T &amp;&amp;x</code> 参数，新结点的元素从 <code>std::move(x)</code> 初始化（这可能是移动，也可能是拷贝，因为在移动操作不可用时，右值也可以拷贝）。</li>
<li>第三个函数接受任意参数，将它们<a href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91">完美转发</a>给 <code>T</code> 的构造函数来初始化新结点的元素。</li>
</ul>
<p><u><strong>这些函数假定上述的初始化能够发生。</strong></u></p>
<p>您需要实现 <code>emplace_front</code> 。</p>
<p>这里我们给出了两个 <code>push_front</code> 的实现，它们都是转而调用 <code>emplace_front</code> ，将真正的工作交给 <code>emplace_front</code> 来完成。也许您可以从这之中获得一些启发，用类似的方式实现其它某些维护性操作。</p>
</li>
<li>
<p><code>pop_front</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>将头结点删除。您需要实现这个函数。</p>
</li>
<li>
<p><code>clear</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  m_head.<span class="built_in">reset</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清空整个链表。如果您对 <code>std::unique_ptr</code> 不是很熟悉，可以思考一下，为什么这样实现能达到目的？</p>
</li>
<li>
<p><code>insert_after</code> 和 <code>emplace_after</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_after</span><span class="params">(const_iterator pos, <span class="type">const</span> T &amp;x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_after</span><span class="params">(const_iterator pos, T &amp;&amp;x)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function">iterator <span class="title">emplace_after</span><span class="params">(const_iterator pos, Types &amp;&amp;...args)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在 <code>pos</code> 所代表的位置<strong>之后</strong>插入一个新的结点。 <code>insert_after</code> 无返回值。 <code>emplace_after</code> 返回指向新创建的元素的迭代器。</p>
<ul>
<li>第一个函数接受 <code>const T &amp;x</code> 参数，新结点的元素由 <code>x</code> 拷贝初始化。</li>
<li>第二个函数接受 <code>T &amp;&amp;x</code> 参数，新结点的元素从 <code>std::move(x)</code> 初始化（这可能是移动，也可能是拷贝，因为在移动操作不可用时，右值也可以拷贝）。</li>
<li>第三个函数接受任意参数，将它们<a href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91">完美转发</a>给 <code>T</code> 的构造函数来初始化新结点的元素。</li>
</ul>
<p><u><strong>这些函数假定上述的初始化能够发生。</strong></u></p>
<p>您需要实现这三个函数。</p>
</li>
<li>
<p><code>erase_after</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase_after</span><span class="params">(const_iterator pos)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">erase_after</span><span class="params">(const_iterator pos, const_iterator last)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个版本删除 <code>pos</code> 所代表的位置的<strong>后一个</strong>结点。</li>
<li>第二个版本删除<strong>开区间</strong> <code>(pos, last)</code> 内的所有结点。</li>
</ul>
<p>在删除完成之后，它们都返回指向 <code>pos</code> 所指位置的后一个结点的迭代器（如果该结点不存在，就是 <code>end()</code> ）。特别地，在第二个版本中，返回的迭代器和 <code>last</code> 指向相同的位置。</p>
</li>
<li>
<p><code>empty</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>判断当前链表是否为空，时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。您需要实现这个函数。</p>
</li>
<li>
<p><code>size</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回当前链表所含的结点个数。您需要实现这个函数。</p>
<p>注意， <code>Slist</code> 的成员变量所保存的信息非常有限，无法支持一个快速的 <code>size()</code> 的实现，因此我们允许 <code>size()</code> 具有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的时间复杂度。</p>
</li>
<li>
<p><code>front</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_head-&gt;value; &#125;</span><br><span class="line"><span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_head-&gt;value; &#125;</span><br></pre></td></tr></table></figure>
<p>返回首元素的引用。</p>
</li>
</ol>
<h3 id="Slist-的比较运算符"><code>Slist</code> 的比较运算符</h3>
<p>这部分只作了解即可。</p>
<p><code>Slist&lt;T&gt;</code> 定义了两个比较运算符，分别是 <code>operator==</code> 和 <code>operator&lt;=&gt;</code> 。在 C++20 下，编译器能够根据这两个运算符合成 <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> 这些比较运算符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Slist&lt;T&gt; &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">equal</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>(), other.<span class="built_in">begin</span>(), other.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Slist&lt;T&gt; &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">lexicographical_compare_three_way</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>(), other.<span class="built_in">begin</span>(),</span><br><span class="line">                                                other.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特殊操作">特殊操作</h3>
<p>除了常规的链表操作（添加、删除、迭代等）之外， <code>Slist&lt;T&gt;</code> 还具有两组特殊操作： <code>merge</code> 和 <code>sort</code> 。</p>
<ol>
<li>
<p><code>merge</code> 归并两个有序链表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(Slist&lt;T&gt; &amp;other)</span> </span>&#123; <span class="built_in">merge</span>(std::<span class="built_in">move</span>(other)); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(Slist&lt;T&gt; &amp;&amp;other)</span> </span>&#123; <span class="built_in">merge</span>(std::<span class="built_in">move</span>(other), std::less&lt;&gt;&#123;&#125;); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(Slist&lt;T&gt; &amp;other, <span class="keyword">auto</span> compare)</span> </span>&#123;</span><br><span class="line"> <span class="built_in">merge</span>(std::<span class="built_in">move</span>(other), compare);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(Slist&lt;T&gt; &amp;&amp;other, <span class="keyword">auto</span> compare)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>merge</code> 操作提供四个接口，其中您需要实现的是第四个，而另外三个都将实际工作转交给第四个。</p>
<ul>
<li>
<p>首先，如果 <code>this == &amp;other</code> ，即 <code>other</code> 和自身表示同一个对象，这个函数什么都不做。</p>
</li>
<li>
<p><code>compare</code> 定义了一个顺序：<code>compare</code> 是一个可调用对象，它接受两个参数 <code>(x, y)</code> ，返回一个 <code>bool</code> 值表示它们比较的结果。我们保证这个 <code>compare</code> 是一个<strong>严格弱序（strict weak ordering）</strong>，即</p>
<ul>
<li>Irreflexivity: <code>compare(a, a)</code> 返回 <code>false</code> ，</li>
<li>Asymmetry: 如果 <code>compare(a, b)</code> 返回 <code>true</code> ，则 <code>compare(b, a)</code> 返回 <code>false</code> ，</li>
<li>Transitivity: 如果 <code>compare(a, b)</code> 和 <code>compare(b, c)</code> 都返回 <code>true</code> ，则 <code>compare(a, c)</code> 返回 <code>true</code> 。</li>
</ul>
<p>给定 <code>compare</code> 的情况下，我们说一个链表是<strong>有序</strong>的，指的是对于链表中的任意两个元素 <code>x</code> 和 <code>y</code> ，如果 <code>compare(x, y)</code> 返回 <code>true</code> ，那么 <code>x</code> 必然排在 <code>y</code> 的前面。</p>
<p><code>merge</code> 操作的前提是 <code>*this</code> 和 <code>other</code> 都是在给定 <code>compare</code> 的情况下<strong>有序</strong>的，否则是未定义的行为。</p>
<p>例如，如果 <code>compare</code> 是 <code>[](const T &amp;x, const T &amp;y) &#123; return x &lt; y; &#125;</code> ，就相当于要求 <code>*this</code> 和 <code>other</code> 里的元素都是已按非递减顺序排序的。</p>
</li>
<li>
<p><code>merge</code> 函数将 <code>other</code> 归并入 <code>*this</code> ，使得 <code>*this</code> 成为一个包含来自两个链表的所有结点的有序链表，而 <code>other</code> 成为一个空链表。注意，这个归并的过程<strong>不能拷贝或移动任何元素</strong>，只能通过修改结点之间的指向关系完成。不能假定 <code>T</code> 是可拷贝的或者可移动的。</p>
</li>
<li>
<p>这个归并需要是 <strong>stable</strong> 的：</p>
<ul>
<li>如果有一对相等的元素分别来自 <code>*this</code> 和 <code>other</code> ，归并完毕后那个来自 <code>*this</code> 的必须排在另一个的前面；</li>
<li>如果有一对相等的元素来自同一个链表，归并完毕后它们的相对顺序不变。</li>
</ul>
</li>
<li>
<p>这个归并的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 是两个链表的元素个数之和。额外空间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。</p>
</li>
</ul>
<p><strong>提示：合理使用 <code>std::unique_ptr&lt;T&gt;::swap</code> ，有奇效。我们只用了 9 行就完成了这个函数。</strong></p>
</li>
<li>
<p><code>sort</code> 对当前链表排序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123; <span class="built_in">sort</span>(std::less&lt;&gt;&#123;&#125;); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">auto</span> compare)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>sort</code> 函数提供两个接口，我们让第二个完成实际的工作，这也是您需要实现的那一个。</p>
<p>与 <code>merge</code> 中的 <code>compare</code> 相同，这里的 <code>compare</code> 也定义了一个严格弱序。在 <code>sort</code> 执行完毕后，对于链表中的任意两个元素 <code>x</code> 和 <code>y</code> ，如果 <code>compare(x, y)</code> 返回 <code>true</code> ，则 <code>x</code> 必然排在 <code>y</code> 的前面。</p>
<p><code>sort</code> 需要在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的时间内完成，并且使用不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的额外空间。</p>
<p><code>sort</code> 需要是 <strong>stable</strong> 的：相等的元素的相对顺序在排序前后不应发生改变。</p>
<p><code>sort</code> 不能拷贝或移动任何元素，只能通过修改结点之间的指向关系完成。不能假定 <code>T</code> 是可拷贝的或者可移动的。</p>
</li>
</ol>
<h2 id="建议实现顺序">建议实现顺序</h2>
<p>建议按照以下顺序完成本题：</p>
<ol>
<li>迭代器的三个函数。</li>
<li><code>push_front</code>, <code>emplace_front</code> 和 <code>pop_front</code> 。这几个函数会让您对创建结点、删除结点的方式有一个基本的认识。</li>
<li><code>insert_after</code>, <code>emplace_after</code>, <code>erase_after</code> 。</li>
<li><code>empty</code>, <code>size</code></li>
<li><code>Slist</code> 的构造函数。您可以充分利用前面已经编写好的插入、删除操作，轻松完成构造函数。</li>
<li><code>merge</code>, <code>sort</code> 。</li>
</ol>
<h2 id="总结">总结</h2>
<p>所有需要实现的函数都已经在代码中标上 <code>// TODO: IMPLEMENT THIS.</code> 。除去这些函数之外，您可以添加一些辅助函数或辅助类，但请不要修改已有的代码。如果您的确有更好的设计（比如尝试实现 <code>before_begin</code> ）但无法在 OJ 上通过编译，可以联系助教。</p>
<p>所有内存管理均使用 <code>std::unique_ptr</code> 完成，您需要保证没有内存泄漏，但是<strong>不可以使用 <code>delete</code></strong> 或其它类似的方式手动释放内存。</p>
<p>在不改变空行、缩进格式的情况下，我们最终完成的 <code>slist.hpp</code> 不超过 240 行，每个维护性操作基本都在 3 行以内。您可以将这个数据作为参考，努力写出简洁的代码。</p>
<p>面对未知的模板类型参数时，请不要随意假定它是可以默认构造、拷贝构造、移动构造、拷贝赋值、移动赋值的；对于那些必须拷贝或移动元素的操作，也请将拷贝或移动的次数降到最低，不要随意假定拷贝或移动是廉价的。</p>
<h2 id="测试点信息">测试点信息</h2>
<ol>
<li>接口编译检查</li>
<li>样例</li>
<li>迭代器</li>
<li>构造函数</li>
<li><code>push_front</code>, <code>emplace_front</code>, <code>pop_front</code></li>
<li><code>push_front</code>, <code>emplace_front</code>, <code>pop_front</code> 压力测试</li>
<li><code>insert_after</code>, <code>emplace_after</code>, <code>erase_after</code></li>
<li><code>insert_after</code>, <code>emplace_after</code>, <code>erase_after</code> 压力测试</li>
<li>检查各项操作中对元素的拷贝、移动的次数</li>
<li><code>merge</code></li>
<li><code>merge</code> stability</li>
<li><code>merge</code> 压力测试</li>
<li><code>sort</code></li>
<li><code>sort</code> stability</li>
<li><code>sort</code> 压力测试</li>
</ol>
<h2 id="附录">附录</h2>
<h3 id="requirements-cpp"><code>requirements.cpp</code></h3>
<p>这份代码采用 C++20 Concepts 列出了 <code>SlistIterator</code> 和 <code>Slist</code> 应当满足的一些特征，比如它们应该声明了哪些类型别名成员、各个成员函数应该可以怎样被调用等等。例如，如果您不小心删除了 <code>SlistIterator</code> 类的 <code>using value_type = T;</code> 这一类型别名成员声明，使用 GCC 13 编译 <code>requirements.cpp</code> 后您将看到这样的报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">requirements.cpp:261:32: error: static assertion failed</span><br><span class="line">  261 | static_assert(iterator_checks::Correct&lt;SlistIterator&gt;);</span><br><span class="line">      |               ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">requirements.cpp:261:32: note: constraints not satisfied</span><br><span class="line">requirements.cpp:74:9:   required for the satisfaction of ‘MemberTypesCorrectOnImpl&lt;Iterator&lt;T, true&gt;, T, true&gt;’ [with T = EmptyType; Iterator = SlistIterator]</span><br><span class="line">requirements.cpp:91:9:   required for the satisfaction of ‘MemberTypesCorrectOn&lt;Iterator, EmptyType&gt;’ [with Iterator = SlistIterator]</span><br><span class="line">requirements.cpp:75:5:   in requirements  [with IterInstance = SlistIterator&lt;EmptyType, true&gt;]</span><br><span class="line">requirements.cpp:76:16: note: the required type ‘typename IterInstance::value_type’ is invalid</span><br><span class="line">   76 |       typename IterInstance::value_type;</span><br><span class="line">      |       ~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">cc1plus: note: set ‘-fconcepts-diagnostics-depth=’ to at least 2 for more detail</span><br></pre></td></tr></table></figure>
<p>然而，GCC 在这方面的表现有时并不令人满意。如果删除 <code>SlistIterator::operator-&gt;()</code> 这个函数的 <code>const</code> qualifier ，GCC 的报错似乎没有追究到底（哪怕设置了 <code>-fconcepts-diagnostics-depth=100</code> 也是如此），它在遇到 fold expression 的时候就不再追究下去了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">requirements.cpp:261:32: error: static assertion failed</span><br><span class="line">  261 | static_assert(iterator_checks::Correct&lt;SlistIterator&gt;);</span><br><span class="line">      |               ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">requirements.cpp:261:32: note: constraints not satisfied</span><br><span class="line">requirements.cpp:137:9:   required for the satisfaction of ‘InterfacesCorrectOn&lt;Iterator, EmptyType, LargeType&gt;’ [with Iterator = SlistIterator]</span><br><span class="line">requirements.cpp:141:76: note: the expression ‘((InterfacesCorrectOnImpl&lt;Iterator&lt;T, true&gt;, T, true&gt;) &amp;&amp; (InterfacesCorrectOnImpl&lt;Iterator&lt;T, false&gt;, T, false&gt;) &amp;&amp; (equality_comparable_with&lt;Iterator&lt;T, true&gt;, Iterator&lt;T, false&gt; &gt;) &amp;&amp; (equality_comparable_with&lt;Iterator&lt;T, false&gt;, Iterator&lt;T, true&gt; &gt;) &amp;&amp; ...) [with T = &#123;EmptyType, LargeType&#125;; Iterator = SlistIterator]’ evaluated to ‘false’</span><br><span class="line">  137 | concept InterfacesCorrectOn = ((</span><br><span class="line">      |                               ~~                                            </span><br><span class="line">  138 |     InterfacesCorrectOnImpl&lt;Iterator&lt;T, true&gt;, T, true&gt; &amp;&amp;</span><br><span class="line">      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                  </span><br><span class="line">  139 |     InterfacesCorrectOnImpl&lt;Iterator&lt;T, false&gt;, T, false&gt; &amp;&amp;</span><br><span class="line">      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                </span><br><span class="line">  140 |     std::equality_comparable_with&lt;Iterator&lt;T, true&gt;, Iterator&lt;T, false&gt;&gt; &amp;&amp;</span><br><span class="line">      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ </span><br><span class="line">  141 |     std::equality_comparable_with&lt;Iterator&lt;T, false&gt;, Iterator&lt;T, true&gt;&gt;)&amp;&amp;...);</span><br><span class="line">      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~</span><br></pre></td></tr></table></figure>
<p>它并没有提到任何有关 <code>operator-&gt;</code> 的信息。幸运的是，Clang 做到了这一点（以下省略了部分重复的报错信息）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">requirements.cpp:261:1: error: static assertion failed</span><br><span class="line">static_assert(iterator_checks::Correct&lt;SlistIterator&gt;);</span><br><span class="line">^             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">requirements.cpp:261:15: note: because &#x27;SlistIterator&#x27; does not satisfy &#x27;Correct&#x27;</span><br><span class="line">static_assert(iterator_checks::Correct&lt;SlistIterator&gt;);</span><br><span class="line">              ^</span><br><span class="line">requirements.cpp:147:19: note: because &#x27;InterfacesCorrectOn&lt;SlistIterator, EmptyType, LargeType&gt;&#x27; evaluated to false</span><br><span class="line">                  InterfacesCorrectOn&lt;Iterator, EmptyType, LargeType&gt;;</span><br><span class="line">                  ^</span><br><span class="line">requirements.cpp:138:5: note: because &#x27;InterfacesCorrectOnImpl&lt;SlistIterator&lt;EmptyType, true&gt;, EmptyType, true&gt;&#x27; evaluated to false</span><br><span class="line">    InterfacesCorrectOnImpl&lt;Iterator&lt;T, true&gt;, T, true&gt; &amp;&amp;</span><br><span class="line">    ^</span><br><span class="line">requirements.cpp:118:9: note: because &#x27;ci.operator-&gt;()&#x27; would be invalid: &#x27;this&#x27; argument to member function &#x27;operator-&gt;&#x27; has type &#x27;const SlistIterator&lt;EmptyType, true&gt;&#x27;, but function is not marked const</span><br><span class="line">      &#123; ci.operator-&gt;() &#125; -&gt; std::same_as&lt;typename IterInstance::pointer&gt;;</span><br><span class="line">        ^</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure>
<p>我们不清楚 MSVC 在这方面的表现。</p>
<h3 id="std-unique-ptr"><code>std::unique_ptr</code></h3>
<p><code>std::unique_ptr&lt;T&gt;</code> 是一种智能指针，它拥有并管理一个 <code>T</code> 类型的对象。当这个 <code>unique_ptr</code> 被析构时，它会自动销毁它所管理的对象并释放其内存，以此保证没有内存泄露。</p>
<p>例如下面这段代码中，我们使用 <code>new</code> 创建了一个 <code>Window</code> 对象之后，必须记得在不用它时手动 <code>delete</code> 来释放内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Window</span>(<span class="type">unsigned</span> width, <span class="type">unsigned</span> height, <span class="type">const</span> std::string &amp;label);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_game</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Window *pWindow = <span class="keyword">new</span> <span class="built_in">Window</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;Plants vs Zombies&quot;</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">delete</span> pWindow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能会想：这有什么难的？不就是在最后记得 <code>delete</code> 吗？——且慢，你怎么确定一定是在“最后”呢？你的代码很有可能是这个样子的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_game</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Window *pWindow = <span class="keyword">new</span> <span class="built_in">Window</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;Plants vs Zombies&quot;</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (condition1) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="comment">/* ... */</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (condition2) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (condition3) &#123;</span><br><span class="line">      <span class="keyword">if</span> (condition4)</span><br><span class="line">        <span class="keyword">throw</span> std::runtime_error&#123;<span class="string">&quot;An error occurred.&quot;</span>&#125;;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你需要记得在所有 <code>return</code> 和 <code>throw</code> 处都 <code>delete pWindow</code> ，这时你还能信心满满地认为你不会遗漏吗？如果现在需要管理的对象不止这一个呢？如果不止这一个函数，并且对象需要在函数之间来回传递呢？</p>
<p>可能更复杂的情形讨论起来有些抽象，但至少上面这段代码的问题可以轻而易举地用 <code>unique_ptr</code> 解决：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_game</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::unique_ptr&lt;Window&gt; pWindow = std::<span class="built_in">make_unique</span>&lt;Window&gt;(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;Plants vs Zombies&quot;</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (condition1) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="comment">/* ... */</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (condition2) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (condition3) &#123;</span><br><span class="line">      <span class="keyword">if</span> (condition4)</span><br><span class="line">        <span class="keyword">throw</span> std::runtime_error&#123;<span class="string">&quot;An error occurred.&quot;</span>&#125;;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只需把开头的裸指针改成 <code>unique_ptr</code> 即可。当执行到 <code>return</code> 或者 <code>throw</code> 时，函数的所有局部对象会被逐个析构，当 <code>pWindow</code> 被析构时它会自动析构它所指向的对象并释放其所占用的内存。</p>
<p>cppreference 描述 <code>std::unique_ptr</code> 的文档可以在<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/memory/unique_ptr">这里</a>看到，你可以暂时忽略其中所有有关 deleter 的内容。常见的 <code>std::unique_ptr</code> 操作有以下这些：</p>
<ul>
<li><code>std::unique_ptr&lt;T&gt; up;</code> 默认初始化一个 <code>std::unique_ptr&lt;T&gt;</code> ， <code>up</code> 被初始化为“不持有任何对象的指针”，就如同“空指针”。</li>
<li><code>std::unique_ptr&lt;T&gt; up(p);</code> ，其中 <code>p</code> 是一个 <code>T*</code> 。创建一个 <code>std::unique_ptr&lt;T&gt;</code> 并接管 <code>p</code> 所指向的对象。通常 <code>p</code> 会是一条 <code>new</code> 表达式： <code>std::unique_ptr&lt;T&gt; up(new T(args...));</code> 。</li>
<li><code>std::make_unique&lt;T&gt;(args...)</code> 动态创建一个 <code>T</code> 类型的对象，使用参数 <code>args...</code> 进行初始化，并返回指向这个对象的 <code>std::unique_ptr&lt;T&gt;</code> 。功能和上一条几乎相同。</li>
<li><code>std::unique_ptr&lt;T&gt; up(std::move(up2))</code> 移动构造 <code>up</code> ，让 <code>up</code> 接管 <code>up2</code> 所持有的对象， <code>up2</code> 不再持有那个对象。</li>
<li><code>up = std::move(up2);</code> 移动赋值。让 <code>up</code> 接管 <code>up2</code> 所持有的对象， <code>up2</code> 不再持有那个对象。如果 <code>up</code> 原本正持有一个对象，那个对象被销毁，其内存被释放。
<ul>
<li>注： <code>std::unique_ptr</code> 是 move-only type ，不可拷贝，只能移动。</li>
</ul>
</li>
<li><code>up.swap(up2)</code> 交换两个 <code>unique_ptr</code> 所持有的对象。</li>
<li><code>*up</code> 获得 <code>up</code> 所指向的对象的引用。 <code>up-&gt;mem</code> 可以访问 <code>up</code> 所指向的对象的名为 <code>mem</code> 的成员。</li>
<li><code>up.get()</code> 获得 <code>up</code> 所指向的对象的裸指针。注意，此类暴露裸指针的操作要慎用，必须确保你不会 <code>delete</code> 由 <code>up.get()</code> 传出的指针。</li>
<li><code>up.reset(p)</code> ，其中 <code>p</code> 是一个 <code>T*</code> （裸指针）。令 <code>up</code> 接管 <code>p</code> 所指向的对象。如果 <code>up</code> 原本正持有一个对象，那个对象被销毁，其内存被释放。</li>
</ul>
<h3 id="完美转发">完美转发</h3>
<p>在某些场合，我们可能需要接受一些数量和类型都不确定的参数，然后把它们都转发给另一个函数。 <code>std::make_unique</code> 就是这样一个例子，它接受任意的参数，然后将它们转发给 <code>T</code> 的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">(<span class="comment">/* parameters */</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(<span class="comment">/* forwarded parameters */</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数在被转发的过程中，它的左右值和 <code>const</code> qualification 不得发生改变。例如，如果传给 <code>make_unique</code> 的参数是一个右值的 <code>std::string</code> 对象， <code>std::make_unique</code> 必须仍然将它以右值的形式转发给 <code>T</code> 的构造函数。如果传进来的是一个非 <code>const</code> 对象，转发时不得私自加上 <code>const</code> 。如果没有做到这一点，就有可能转发不到想要的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Arg&gt;</span><br><span class="line"><span class="function">std::unique_ptr&lt;T&gt; <span class="title">make_unique_fake</span><span class="params">(<span class="type">const</span> Arg &amp;arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(arg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::string a = <span class="built_in">some_value</span>(), b = <span class="built_in">some_other_value</span>();</span><br><span class="line"><span class="keyword">auto</span> sup = <span class="built_in">make_unique_fake</span>(a + b);</span><br></pre></td></tr></table></figure>
<p>这里 <code>a + b</code> 作为一个右值本应该被 move ，但 <code>make_unique_fake</code> 接受它时已经将它变成了左值 <code>const std::string &amp;</code> （而且还带 <code>const</code>），于是移动变成了拷贝。</p>
<p>为了实现完美转发，我们需要使用<strong>万能引用</strong>（universal reference）接受参数，同时为了接受任意多个任意类型的参数，我们使用可变参数模板（variadic template）。这里细节的解释略去。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function">std::unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">(Types &amp;&amp;...args)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这样就能保证参数在传进来的时候，没有额外的拷贝或移动，没有添加或删除 <code>const</code> qualification ，并且左右值信息仍然存在。为了转发 <code>args</code> ，我们需要使用标准库函数 <code>std::forward</code> ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function">std::unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">(Types &amp;&amp;...args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Types&gt;(args)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们可以来看一看 <code>SlistNode</code> 的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="built_in">SlistNode</span>(std::unique_ptr&lt;SlistNode&lt;T&gt;&gt; &amp;&amp;nxt, Types &amp;&amp;...args)</span><br><span class="line">    : <span class="built_in">next</span>(std::<span class="built_in">move</span>(nxt)), <span class="built_in">value</span>(std::forward&lt;Types&gt;(args)...) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们要使用 <code>std::make_unique&lt;SlistNode&lt;T&gt;&gt;</code> 动态创建一个 <code>SlistNode&lt;T&gt;</code> 对象，那些用来初始化 <code>T</code> 类型的元素的参数就经历了两次完美转发：首先被 <code>std::make_unique</code> 转发给 <code>SlistNode&lt;T&gt;</code> 的构造函数，然后被转发给 <code>T</code> 的构造函数。</p>
<p>特别地，在使用可变参数模板时，参数个数可以为零。如果最终初始化 <code>value</code> 时没有任何参数，那就是在对 <code>value</code> 进行<strong>值初始化</strong>（value-initialization）。</p>
<h1 id="Problem-2-Hash-Table">Problem 2. Hash Table</h1>
<p>In this problem, you are required to implement a hash table to achieve fast key-value insertion and look-up.</p>
<p>The background of our problem is set to the DNS service. We need to find the IP address corresponding to the given domain name. This is a classical problem solved by a hash table.</p>
<p><strong>NOTE</strong>: You can not use STL data structures, such as <code>std::unordered_map</code>, <code>std::unordered_set</code>, <code>std::map</code> and <code>std::set</code>, in this problem. <strong>All of your hash tables should be designed by yourself.</strong></p>
<p>The files attached to this problem are shown as follows. We provide some tests to help you check your code.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── attachments/</span><br><span class="line">    ├── tests/</span><br><span class="line">    │   ├── clear.cpp</span><br><span class="line">    │   ├── erase.cpp</span><br><span class="line">    │   ├── hash_function.cpp</span><br><span class="line">    │   ├── insert.cpp</span><br><span class="line">    │   └── probing.cpp</span><br><span class="line">    ├── requirements.cpp</span><br><span class="line">    ├── hash_table.hpp</span><br><span class="line">    └── hash_types.hpp</span><br></pre></td></tr></table></figure>
<h2 id="Hash-Function">Hash Function</h2>
<p>In this part, you are required to implement a hash function for <code>class Website</code>.</p>
<p><code>class Website</code> only has one private member <code>std::string name</code>, which represents the website's domain name. So our goal is to design a hash function for a string consisting of <strong>ASCII characters</strong>.</p>
<p>For our problem, you need to implement a specific hash function for string hash.</p>
<p>Suppose the string <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> has a length of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>, we could write string <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>0</mn></msub><msub><mi>s</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>s</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">s_0s_1...s_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>. Our hash function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span> for string <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> is defined as follows:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>s</mi><mn>0</mn></msub><msup><mi>b</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><msub><mi>s</mi><mn>1</mn></msub><msup><mi>b</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>s</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub><mi>b</mi><mo>+</mo><msub><mi>s</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mspace></mspace><mspace width="1em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><msup><mn>2</mn><mn>32</mn></msup></mspace></mrow><annotation encoding="application/x-tex">f(s) = (s_0b^{n-1} + s_1b^{n-2}+\dots+s_{n-2}b + s_{n-1}) \mod 2^{32}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0141em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9028em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is the character's ASCII code in numerical forms and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mn>1009</mn></mrow><annotation encoding="application/x-tex">b=1009</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1009</span></span></span></span> is a constant.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::hash&lt;Website&gt;&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> base = <span class="number">1009u</span>;<span class="comment">// 1009 is a prime number.</span></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> Website &amp;S)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Implement the hash function here. Suppose <code>y</code> is an instance of <code>class Website</code>, Call <code>std::hash&lt;Website&gt;&#123;&#125;(y)</code> to obtain the hash value of <code>y</code>. We will check whether you implement the hash function correctly.</p>
<p>(Hint: Integer overflow on a 32-bit unsigned integer is equal to modulus by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span>.)</p>
<h2 id="Hash-Table">Hash Table</h2>
<p>In this part, you should implement a hash table with key type <code>class Key</code> and value type <code>class T</code>. Your hash table should support <strong>insert, find, erase and clear</strong> operation.</p>
<p>First, your hash table has a constant size of <code>Mod=1000037</code>. An object <code>y</code> should be mapped into the position <code>std::hash&lt;Key&gt;&#123;&#125;(y) % Mod</code>.</p>
<p>Second, you should deal with hash collisions using <strong>Linear Probing</strong> or <strong>Quadratic Probing</strong>.</p>
<p>Third, implement the erase operation with <strong>Lazy Erasing</strong>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span> = Website, <span class="keyword">class</span> T = IPv4&gt;     <span class="comment">// template for key type class Key and value type class T</span></span><br><span class="line"><span class="keyword">class</span> HashTable&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> entrystate&#123;</span><br><span class="line">        Unused, Used, Erased</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> Mod = <span class="number">1000037u</span>;   <span class="comment">// 1000037 is a prime number</span></span><br><span class="line">    std::vector&lt;T&gt; Table;          <span class="comment">// main table stores value</span></span><br><span class="line">    std::vector&lt;Key&gt; Stored_Key;   <span class="comment">// used for storing original key</span></span><br><span class="line">    std::vector&lt;entrystate&gt; State; <span class="comment">// keeps the state of every table entry : &#123;Unused, Used or Erased&#125;;</span></span><br><span class="line">    std::vector&lt;<span class="type">size_t</span>&gt; Used_pos;  <span class="comment">// hint: used for function clear()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::<span class="type">size_t</span> npos = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">HashTable</span>() : <span class="built_in">Table</span>(Mod),<span class="built_in">Stored_Key</span>(Mod),<span class="built_in">State</span>(Mod, entrystate::Unused) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> T&amp; <span class="keyword">operator</span> [] (<span class="type">const</span> Key &amp;x) <span class="type">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="type">size_t</span> pos = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (pos==npos) <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Key does not exist&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Table[pos];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">Search</span><span class="params">(<span class="type">const</span> Key &amp;x)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> Key &amp;x)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> Key &amp;x, T value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> Key &amp;x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Requirements for member functions:</p>
<p><code>std::size_t Search(const Key &amp;x) const</code>:</p>
<p>If <code>Key x</code> already exists in the table,  <code>std::size_t Search(const Key &amp;x) const</code> should return the position where <code>Key x</code> is stored in the table.</p>
<p>If <code>Key x</code> does not exist in the table, <code>std::size_t Search(const Key &amp;x) const</code> should return a position to insert <code>Key x</code> into this position.</p>
<p><code>std::size_t find(const Key &amp;x) const</code>:</p>
<p>If <code>Key x</code> already exists in the table,  <code>std::size_t find(const Key &amp;x) const</code> should return the position where <code>Key x</code> is stored in the table.</p>
<p>If <code>Key x</code> does not exist in the table, <code>std::size_t find(const Key &amp;x) const</code> should return <code>npos</code>.</p>
<p><code>void insert(const Key &amp;x, const T &amp;value)</code>:</p>
<p>Insert <code>Key x</code> into the table, and store its corresponding value <code>T value</code>.<br>
If <code>Key x</code> already exists in the table, update its corresponding value to the newly inserted <code>const T &amp;value</code>.</p>
<p>You needn't consider the situations where the hash table has no place to insert this <code>Key x</code>. We will guarantee the table cannot be full.</p>
<p><code>bool erase(const Key &amp;x):</code></p>
<p>If <code>Key x</code> exists in the table, erase the table entry of <code>Key x</code> using <strong>Lazy erasing</strong>. After this operation, return <code>true</code>.</p>
<p>If <code>Key x</code> does not exist in the table, just return <code>false</code> and the table remains unchanged.</p>
<p><code>void clear()</code>:</p>
<p>This operation would clear all table entries in the hash table, in other words, erase all elements in the hash table.</p>
<p>Your time complexity of this operation should be independent of the size of the hash table.</p>
<h1 id="Problem-3-Quick-Sort">Problem 3. Quick Sort</h1>
<p>In this problem, you are required to implement a quick sort algorithm.</p>
<p>Recall: The algorithm selects a pivot element from the array and partitions the other entries into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are<br>
then recursively sorted using the same process until the entire array is sorted.</p>
<p>The files attached to this problem are shown as follows. We provide a test to help you check your code.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── attachments/</span><br><span class="line">    ├── tests/</span><br><span class="line">    │   └── test_sorting.cpp</span><br><span class="line">    └── quick_sort.hpp</span><br></pre></td></tr></table></figure>
<p><strong>NOTE</strong>:</p>
<ol>
<li>You should <strong>NEVER</strong> call the copy constructor of data type in the whole algorithm.</li>
<li>You should <strong>NEVER</strong> call <code>std::sort()</code> or use other algorithms to complete sort in the whole algorithm.</li>
<li>In the algorithm, you should keep partitioning the whole array with pivots until there is <strong>no more than one entry in the part</strong>.</li>
</ol>
<p>In the template, we have provided a function named <code>random_choice</code>. You should pass two <em>Random Access Iterators</em> to them. The return value will be an iterator pointing to a randomly chosen entry.</p>
<p>Here is an example of usage:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector a&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; *<span class="built_in">random_choice</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; *<span class="built_in">random_choice</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; *<span class="built_in">random_choice</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A possible output could be:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<h2 id="Requirements">Requirements:</h2>
<p>Your task is to complete the function <code>void quick_sort(std::random_access_iterator auto begin, std::random_access_iterator auto end, auto compare)</code>. About the usage of <code>compare</code>, you could refer to the description &quot;特殊操作&quot; of <code>prob1: Slist</code>.</p>
<p>After sorting, you should guarantee that for every two iterators <code>x</code>, <code>y</code> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo><mo stretchy="false">[</mo></mrow><annotation encoding="application/x-tex">\in[</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span></span></span></span><code>begin</code>, <code>end</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span>, whenever <code>compare(*x, *y)</code> returns <code>true</code>, we have <code>x &lt; y</code>.</p>
<h1 id="评分">评分</h1>
<p>评分由 OJ 分数（60%）和线下 check （40%）两部分构成。线下 check 会在此次作业结束时间之后进行。</p>
<p>注：线下 check 也带有检查学术诚信的含义，当然这不是唯一的手段。如果被认定为抄袭， OJ 的分数也会作废，并且会有惩罚。<strong>特别强调，抄袭来自 generative AI 的代码和抄袭网上的代码是同等处理的，我们建议您在写作业时关闭一切 generative AI 工具。</strong></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E4%BD%9C%E4%B8%9A/" rel="tag"># 作业</a>
              <a href="/tags/%E4%B8%8A%E7%A7%91%E5%A4%A7/" rel="tag"># 上科大</a>
              <a href="/tags/CS110/" rel="tag"># CS110</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2024/01/25/Compile-Basics/" rel="prev" title="Compile Basics">
      <i class="fa fa-chevron-left"></i> Compile Basics
    </a></div>
      <div class="post-nav-item">
    <a href="/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2024/01/26/CS101-PA-2/" rel="next" title="CS101 PA [2]">
      CS101 PA [2] <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Problem-1-Singly-linked-list"><span class="nav-text">Problem 1. Singly-linked list</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95"><span class="nav-text">目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B"><span class="nav-text">开始</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SlistNode-%E7%B1%BB"><span class="nav-text">SlistNode 类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SlistIterator-%E7%B1%BB"><span class="nav-text">SlistIterator 类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Slist-%E7%B1%BB"><span class="nav-text">Slist 类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Slist-%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">Slist 的构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Slist-%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E6%88%90%E5%91%98"><span class="nav-text">Slist 的拷贝控制成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Slist-%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">Slist 的迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Slist-%E7%9A%84%E7%BB%B4%E6%8A%A4%E6%80%A7%E6%93%8D%E4%BD%9C"><span class="nav-text">Slist 的维护性操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Slist-%E7%9A%84%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">Slist 的比较运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%93%8D%E4%BD%9C"><span class="nav-text">特殊操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%BA%E8%AE%AE%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F"><span class="nav-text">建议实现顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%82%B9%E4%BF%A1%E6%81%AF"><span class="nav-text">测试点信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%84%E5%BD%95"><span class="nav-text">附录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#requirements-cpp"><span class="nav-text">requirements.cpp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-unique-ptr"><span class="nav-text">std::unique_ptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="nav-text">完美转发</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Problem-2-Hash-Table"><span class="nav-text">Problem 2. Hash Table</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash-Function"><span class="nav-text">Hash Function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash-Table"><span class="nav-text">Hash Table</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Problem-3-Quick-Sort"><span class="nav-text">Problem 3. Quick Sort</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Requirements"><span class="nav-text">Requirements:</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%84%E5%88%86"><span class="nav-text">评分</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zivmax"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Zivmax</p>
  <div class="site-description" itemprop="description">记录我在 STU 的所见所闻,以及成长</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
          
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zivmax" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zivmax" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:marsh.mallow@foxmail.com" title="E-Mail → mailto:marsh.mallow@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/wechat/" title="Wechat → &#x2F;wechat&#x2F;"><i class="fab fa-weixin fa-fw"></i>Wechat</a>
      </span>
      <span class="links-of-author-item">
        <a href="/QQ/" title="QQ → &#x2F;QQ&#x2F;"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
          
        </div>
  
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-8-11 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-flag"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zivmax</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>




        








      </div>
    </footer>
  </div>

  
  <script color='255,255,255' opacity='0.8' zIndex='-1' count='120' src="/lib/canvas-nest/canvas-nest-nomobile.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">
  <script src="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.js"></script>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.css">


  

    </div>


</body>
</html>

